// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.6 (swiftlang-5.6.0.323.62 clang-1316.0.20.8)
// swift-module-flags: -target arm64-apple-ios11.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name cryptography
import CommonCrypto
import Darwin
import Foundation
import Network
import ObjectiveC
import PDFKit
import Security
import Swift
import UIKit
import _Concurrency
@_exported import cryptography
import zlib
public enum CCError : cryptography.CC.CCCryptorStatus, Swift.Error {
  case paramError
  case bufferTooSmall
  case memoryFailure
  case alignmentError
  case decodeError
  case unimplemented
  case overflow
  case rngFailure
  case unspecifiedError
  case callSequenceError
  case keySizeError
  case invalidKey
  public static var debugLevel: Swift.Int
  public init?(rawValue: cryptography.CC.CCCryptorStatus)
  public typealias RawValue = cryptography.CC.CCCryptorStatus
  public var rawValue: cryptography.CC.CCCryptorStatus {
    get
  }
}
@_hasMissingDesignatedInitializers open class PKCS8PublicKey {
  public static func addHeader(_ derKey: Foundation.Data) -> Foundation.Data
  public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
  public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
  public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
  @objc deinit
}
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: cryptography.FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: cryptography.ServerEvent)
}
public enum ServerEvent {
  case connected(cryptography.Connection, [Swift.String : Swift.String])
  case disconnected(cryptography.Connection, Swift.String, Swift.UInt16)
  case text(cryptography.Connection, Swift.String)
  case binary(cryptography.Connection, Foundation.Data)
  case pong(cryptography.Connection, Foundation.Data?)
  case ping(cryptography.Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
}
@_hasMissingDesignatedInitializers public class Log {
  public static func print(_ items: Swift.String..., filename: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, separator: Swift.String = " ", terminator: Swift.String = "\n")
  public static func print(_ items: Any..., separator: Swift.String = " ", terminator: Swift.String = "\n")
  @objc deinit
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: cryptography.HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: cryptography.HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: cryptography.HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: cryptography.HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> cryptography.URLParts?
}
public protocol MSAUDataSendingDelegate {
  func sendUUIDData(uuid: Swift.String)
}
@_hasMissingDesignatedInitializers public class MSAU {
  public var delegate: cryptography.MSAUDataSendingDelegate?
  public static var uiKitConfigMSAU: cryptography.MSSUIKitConfig
  public static func getInstance() -> cryptography.MSAU
  public func initialize(window: UIKit.UIWindow, config: cryptography.MSSUIKitConfig) throws
  public func showMSAUUI(host: UIKit.UIViewController)
  public func showRegistrationByOTP(host: UIKit.UIViewController) throws
  public func showRegistrationBySignedMsisdn(host: UIKit.UIViewController, msisdn: Swift.String, signedMsisdn: Swift.String) throws
  public func showSignPdfMock()
  public func showLoginErorrDialog(message: Swift.String)
  public func showChangePassword() throws
  public func getUUID() -> Swift.String
  public func getHovitaUUID() -> Swift.String
  public func isUserRegistered() -> Swift.Bool
  public enum CustomError : Swift.Error {
    case CONFIGURATION_NOT_AVAILABLE
    case PHONE_NUM_NOT_VALID
    case NATIONAL_ID_NOT_VALID
    case USER_NOT_REGISTERED
    case USER_NOT_AUTHENTICATED
    case USER_REGISTERED_PREVIOUSLY
    case DEPRECATED_SDK_VERSION
    case unexpected(code: Swift.Int)
  }
  @objc deinit
}
extension cryptography.MSAU : cryptography.WebSocketDelegate {
  public func didReceive(event: cryptography.WebSocketEvent, client: cryptography.WebSocketClient)
}
public protocol CryptoSwiftCryptor {
  mutating func seek(to: Swift.Int) throws
}
public protocol CryptoSwiftCryptors : AnyObject {
  func makeEncryptor() throws -> cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
  func makeDecryptor() throws -> cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
  static func randomIV(_ blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
}
extension cryptography.CryptoSwiftCryptors {
  public static func randomIV(_ count: Swift.Int) -> Swift.Array<Swift.UInt8>
}
@_hasMissingDesignatedInitializers open class EC {
  public static func generateKeyPair(_ keySize: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
  public static func getPublicKeyFromPrivateKey(_ privateKey: Foundation.Data) throws -> Foundation.Data
  public static func signHash(_ privateKey: Foundation.Data, hash: Foundation.Data) throws -> Foundation.Data
  public static func verifyHash(_ publicKey: Foundation.Data, hash: Foundation.Data, signedData: Foundation.Data) throws -> Swift.Bool
  public static func computeSharedSecret(_ privateKey: Foundation.Data, publicKey: Foundation.Data) throws -> Foundation.Data
  public struct KeyComponents {
    public init(_ keySize: Swift.Int, _ x: Foundation.Data, _ y: Foundation.Data, _ d: Foundation.Data)
    public var keySize: Swift.Int
    public var x: Foundation.Data
    public var y: Foundation.Data
    public var d: Foundation.Data
  }
  public static func getPublicKeyComponents(_ keyData: Foundation.Data) throws -> cryptography.EC.KeyComponents
  public static func getPrivateKeyComponents(_ keyData: Foundation.Data) throws -> cryptography.EC.KeyComponents
  public static func createFromData(_ keySize: Darwin.size_t, _ x: Foundation.Data, _ y: Foundation.Data) throws -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
public enum BlockMode : cryptography.CC.CCMode {
  case ecb, cbc, cfb, ctr, f8, lrw, ofb, xts, rc4, cfb8
  public init?(rawValue: cryptography.CC.CCMode)
  public typealias RawValue = cryptography.CC.CCMode
  public var rawValue: cryptography.CC.CCMode {
    get
  }
}
public struct CryptoSwiftCTR {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftCTR.Error, b: cryptography.CryptoSwiftCTR.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, counter: Swift.Int = 0)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
@_hasMissingDesignatedInitializers public class X509PublicKey {
  public var algOid: Swift.String? {
    get
  }
  public var algName: Swift.String? {
    get
  }
  public var algParams: Swift.String? {
    get
  }
  public var derEncodedKey: Foundation.Data? {
    get
  }
  public var key: Foundation.Data? {
    get
  }
  @objc deinit
}
extension cryptography.ChaCha20 {
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@usableFromInline
final internal class CryptoSwiftBlockEncryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: cryptography.CryptoSwiftCipherModeWorker) throws
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension UIKit.UIFont {
  public static let loadAllFonts: ()
}
extension UIKit.UIFont {
  public static func registerCustomFontsIfNeeded()
}
public protocol _UInt8TypeCryptoSwift {
}
extension Swift.UInt8 : cryptography._UInt8TypeCryptoSwift {
}
extension Swift.UInt8 {
  public func bits() -> [cryptography.CryptoSwiftBit]
  public func bits() -> Swift.String
}
@_hasMissingDesignatedInitializers open class CCM {
  public static func crypt(_ opMode: cryptography.OpMode, algorithm: cryptography.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
  public static func available() -> Swift.Bool
  @objc deinit
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: cryptography.FoundationTransportError, b: cryptography.FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, cryptography.Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: cryptography.CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: cryptography.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
extension cryptography.CryptoSwiftPKCS5 {
  public struct CryptoSwiftPBKDF1 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error, b: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public enum Variant {
      case md5, sha1
      @usableFromInline
      internal var size: Swift.Int {
        get
      }
      @usableFromInline
      internal func calculateHash(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
      public static func == (a: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant, b: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    @usableFromInline
    internal let iterations: Swift.Int
    @usableFromInline
    internal let variant: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant
    @usableFromInline
    internal let keyLength: Swift.Int
    @usableFromInline
    internal let t1: Swift.Array<Swift.UInt8>
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant = .sha1, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil) throws
    @inlinable public func calculate() -> Swift.Array<Swift.UInt8> {
      var t = self.t1
      for _ in 2...self.iterations {
        t = self.variant.calculateHash(t)
      }
      return Array(t[0..<self.keyLength])
    }
  }
}
@_hasMissingDesignatedInitializers open class KeyStoreEditor {
  public static func upsertKey(_ pemKey: Swift.String, keyTag: Swift.String, options: [Foundation.NSString : Swift.AnyObject] = [:]) throws
  public static func getKey(_ keyTag: Swift.String) throws -> Swift.String
  public static func delKey(_ keyTag: Swift.String) throws
  @objc deinit
}
extension Swift.String {
  public func isValidIranianNationallCode() -> Swift.Bool
  public var replacedArabicDigitsWithEnglish: Swift.String {
    get
  }
}
extension Swift.Collection where Self.Element == Swift.UInt8, Self.Index == Swift.Int {
  @inlinable internal func toUInt32Array() -> Swift.Array<Swift.UInt32> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 4)
    return Array<UInt32>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 4) {
        let val = UInt32(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
  @inlinable internal func toUInt64Array() -> Swift.Array<Swift.UInt64> {
    guard !isEmpty else {
      return []
    }

    let c = strideCount(from: startIndex, to: endIndex, by: 8)
    return Array<UInt64>(unsafeUninitializedCapacity: c) { buf, count in
      var counter = 0
      for idx in stride(from: startIndex, to: endIndex, by: 8) {
        let val = UInt64(bytes: self, fromIndex: idx).bigEndian
        buf[counter] = val
        counter += 1
      }
      count = counter
      assert(counter == c)
    }
  }
}
@usableFromInline
internal func strideCount(from: Swift.Int, to: Swift.Int, by: Swift.Int) -> Swift.Int
final public class CryptoSwiftSHA2 {
  @usableFromInline
  final internal let variant: cryptography.CryptoSwiftSHA2.Variant
  @usableFromInline
  final internal let size: Swift.Int
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let digestLength: Swift.Int
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash32: [Swift.UInt32]
  @usableFromInline
  final internal var accumulatedHash64: [Swift.UInt64]
  @frozen public enum Variant : Swift.RawRepresentable {
    case sha224, sha256, sha384, sha512
    public var digestLength: Swift.Int {
      get
    }
    public var blockSize: Swift.Int {
      get
    }
    public typealias RawValue = Swift.Int
    public var rawValue: cryptography.CryptoSwiftSHA2.Variant.RawValue {
      get
    }
    public init?(rawValue: cryptography.CryptoSwiftSHA2.Variant.RawValue)
    @usableFromInline
    internal var h: Swift.Array<Swift.UInt64> {
      get
    }
    @usableFromInline
    internal var finalLength: Swift.Int {
      get
    }
  }
  public init(variant: cryptography.CryptoSwiftSHA2.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process64(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @usableFromInline
  final internal func process32(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.Array<Swift.UInt32>)
  @objc deinit
}
extension cryptography.CryptoSwiftSHA2 : cryptography.CryptoSwiftUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: self.blockSize / 8) // A 64-bit/128-bit representation of b. blockSize fit by accident.

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: self.blockSize, allowance: self.blockSize / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        switch self.variant {
          case .sha224, .sha256:
            self.process32(block: chunk, currentHash: &self.accumulatedHash32)
          case .sha384, .sha512:
            self.process64(block: chunk, currentHash: &self.accumulatedHash64)
          }
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: variant.digestLength)
    switch self.variant {
      case .sha224, .sha256:
        var pos = 0
        for idx in 0..<self.accumulatedHash32.count where idx < self.variant.finalLength {
          let h = accumulatedHash32[idx]
          result[pos + 0] = UInt8((h >> 24) & 0xff)
          result[pos + 1] = UInt8((h >> 16) & 0xff)
          result[pos + 2] = UInt8((h >> 8) & 0xff)
          result[pos + 3] = UInt8(h & 0xff)
          pos += 4
        }
      case .sha384, .sha512:
        var pos = 0
        for idx in 0..<self.accumulatedHash64.count where idx < self.variant.finalLength {
          let h = accumulatedHash64[idx]
          result[pos + 0] = UInt8((h >> 56) & 0xff)
          result[pos + 1] = UInt8((h >> 48) & 0xff)
          result[pos + 2] = UInt8((h >> 40) & 0xff)
          result[pos + 3] = UInt8((h >> 32) & 0xff)
          result[pos + 4] = UInt8((h >> 24) & 0xff)
          result[pos + 5] = UInt8((h >> 16) & 0xff)
          result[pos + 6] = UInt8((h >> 8) & 0xff)
          result[pos + 7] = UInt8(h & 0xff)
          pos += 8
        }
    }

    // reset hash value for instance
    if isLast {
      switch self.variant {
        case .sha224, .sha256:
          self.accumulatedHash32 = self.variant.h.lazy.map { UInt32($0) } // FIXME: UInt64 for process64
        case .sha384, .sha512:
          self.accumulatedHash64 = self.variant.h
      }
    }

    return result
  }
}
final public class Checksum {
  @usableFromInline
  internal static let table32: [Swift.UInt32]
  @usableFromInline
  internal static let table32c: [Swift.UInt32]
  @usableFromInline
  internal static let table16: [Swift.UInt16]
  @usableFromInline
  internal init()
  @inlinable final internal func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    var crc: UInt32 = seed != nil ? seed! : 0xFFFF_FFFF
    for chunk in message.batched(by: 256) {
      for b in chunk {
        let idx = Int((crc ^ UInt32(reflect ? b : reversed(b))) & 0xFF)
        crc = (crc >> 8) ^ Checksum.table32c[idx]
      }
    }
    return (reflect ? crc : reversed(crc)) ^ 0xFFFF_FFFF
  }
  @inlinable final internal func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    var crc: UInt16 = seed != nil ? seed! : 0x0000
    for chunk in message.batched(by: 256) {
      for b in chunk {
        crc = (crc >> 8) ^ Checksum.table16[Int((crc ^ UInt16(b)) & 0xFF)]
      }
    }
    return crc
  }
  @objc deinit
}
extension cryptography.Checksum {
  @inlinable public static func crc32(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc32c(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32 {
    Checksum().crc32c(message, seed: seed, reflect: reflect)
  }
  @inlinable public static func crc16(_ message: Swift.Array<Swift.UInt8>, seed: Swift.UInt16? = nil) -> Swift.UInt16 {
    Checksum().crc16(message, seed: seed)
  }
}
public class CryptoSwiftBlockDecryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  internal var worker: cryptography.CryptoSwiftCipherModeWorker
  @usableFromInline
  internal var accumulated: [Swift.UInt8]
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: cryptography.CryptoSwiftCipherModeWorker) throws
  @inlinable public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    // If a worker (eg GCM) can combine ciphertext + tag
    // we need to remove tag from the ciphertext.
    if !isLast && self.accumulated.count < self.blockSize + self.worker.additionalBufferSize {
      return []
    }

    let accumulatedWithoutSuffix: Array<UInt8>
    if self.worker.additionalBufferSize > 0 {
      // FIXME: how slow is that?
      accumulatedWithoutSuffix = Array(self.accumulated.prefix(self.accumulated.count - self.worker.additionalBufferSize))
    } else {
      accumulatedWithoutSuffix = self.accumulated
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: accumulatedWithoutSuffix.count)
    // Processing in a block-size manner. It's good for block modes, but bad for stream modes.
    for var chunk in accumulatedWithoutSuffix.batched(by: self.blockSize) {
      if isLast || (accumulatedWithoutSuffix.count - processedBytesCount) >= blockSize {
        let isLastChunk = processedBytesCount + chunk.count == accumulatedWithoutSuffix.count

        if isLast, isLastChunk, var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker {
          chunk = try finalizingWorker.willDecryptLast(bytes: chunk + accumulated.suffix(worker.additionalBufferSize)) // tag size
        }

        if !chunk.isEmpty {
          plaintext += worker.decrypt(block: chunk)
        }

        if isLast, isLastChunk, var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker {
          plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
        }

        processedBytesCount += chunk.count
      }
    }
    accumulated.removeFirst(processedBytesCount) // super-slow

    if isLast {
      if accumulatedWithoutSuffix.isEmpty, var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker {
        try finalizingWorker.willDecryptLast(bytes: self.accumulated.suffix(self.worker.additionalBufferSize))
        plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
      }
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize)
    }

    return plaintext
  }
  public func seek(to position: Swift.Int) throws
  @objc deinit
}
extension Foundation.FileManager {
  public static var documentsDirectoryURL: Foundation.URL {
    get
  }
}
public class WSEngine : cryptography.Engine, cryptography.TransportEventClient, cryptography.FramerEventClient, cryptography.FrameCollectorDelegate, cryptography.HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: cryptography.Transport, certPinner: cryptography.CertificatePinning? = nil, headerValidator: cryptography.HeaderValidator = FoundationSecurity(), httpHandler: cryptography.HTTPHandler = FoundationHTTPHandler(), framer: cryptography.Framer = WSFramer(), compressionHandler: cryptography.CompressionHandler? = nil)
  public func register(delegate: cryptography.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: cryptography.FrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: cryptography.ConnectionState)
  public func didReceiveHTTP(event: cryptography.HTTPEvent)
  public func frameProcessed(event: cryptography.FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: cryptography.FrameCollector.Event)
  @objc deinit
}
extension cryptography.PKCS7 {
  public struct ReceiptInfo {
    public var bundleIdentifier: Swift.String? {
      get
    }
    public var bundleIdentifierData: Foundation.Data? {
      get
    }
    public var bundleVersion: Swift.String? {
      get
    }
    public var originalApplicationVersion: Swift.String? {
      get
    }
    public var opaqueValue: Foundation.Data? {
      get
    }
    public var sha1: Foundation.Data? {
      get
    }
    public var receiptCreationDate: Foundation.Date? {
      get
    }
    public var receiptCreationDateString: Swift.String? {
      get
    }
    public var receiptExpirationDate: Foundation.Date? {
      get
    }
    public var receiptExpirationDateString: Swift.String? {
      get
    }
    public var inAppPurchases: [cryptography.PKCS7.InAppPurchaseInfo]? {
      get
    }
  }
  public struct InAppPurchaseInfo {
    public var quantity: Swift.UInt64? {
      get
    }
    public var productId: Swift.String? {
      get
    }
    public var transactionId: Swift.String? {
      get
    }
    public var originalTransactionId: Swift.String? {
      get
    }
    public var purchaseDate: Foundation.Date? {
      get
    }
    public var originalPurchaseDate: Foundation.Date? {
      get
    }
    public var expiresDate: Foundation.Date? {
      get
    }
    public var isInIntroOfferPeriod: Swift.UInt64? {
      get
    }
    public var cancellationDate: Foundation.Date? {
      get
    }
    public var webOrderLineItemId: Swift.UInt64? {
      get
    }
  }
  public func receipt() -> cryptography.PKCS7.ReceiptInfo?
}
extension cryptography.CryptoSwiftAES : cryptography.CryptoSwiftCryptors {
  @inlinable final public func makeEncryptor() throws -> cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable {
    let blockSize = blockMode.customBlockSize ?? CryptoSwiftAES.blockSize
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: encrypt, encryptionOperation: encrypt)
    if worker is CryptoSwiftStreamModeWorker {
      return try CryptoSwiftStreamEncryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try CryptoSwiftBlockEncryptor(blockSize: blockSize, padding: padding, worker)
  }
  @inlinable final public func makeDecryptor() throws -> cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable {
    let blockSize = blockMode.customBlockSize ?? CryptoSwiftAES.blockSize
    let cipherOperation: CipherOperationOnBlock = blockMode.options.contains(.useEncryptToDecrypt) == true ? encrypt : decrypt
    let worker = try blockMode.worker(blockSize: blockSize, cipherOperation: cipherOperation, encryptionOperation: encrypt)
    if worker is CryptoSwiftStreamModeWorker {
      return try CryptoSwiftStreamDecryptor(blockSize: blockSize, padding: padding, worker)
    }
    return try CryptoSwiftBlockDecryptor(blockSize: blockSize, padding: padding, worker)
  }
}
@_hasMissingDesignatedInitializers open class PEMEncryptedPrivateKey {
  public enum EncMode {
    case aes128CBC, aes256CBC
    public static func == (a: cryptography.PEMEncryptedPrivateKey.EncMode, b: cryptography.PEMEncryptedPrivateKey.EncMode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static func toDER(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Foundation.Data
  public static func toPEM(_ derKey: Foundation.Data, passphrase: Swift.String, mode: cryptography.PEMEncryptedPrivateKey.EncMode) -> Swift.String
  @objc deinit
}
public enum KeyType : Swift.String {
  case RSA_1024
  case RSA_1280
  case RSA_1536
  case RSA_1984
  case RSA_2048
  case RSA_4096
  public var size: Swift.Int {
    get
  }
  public var type: Swift.String {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@usableFromInline
internal struct CryptoSwiftBatchedCollectionIndex<Base> where Base : Swift.Collection {
}
extension cryptography.CryptoSwiftBatchedCollectionIndex : Swift.Comparable {
  @usableFromInline
  internal static func == <Base>(lhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>, rhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
  @usableFromInline
  internal static func < <Base>(lhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>, rhs: cryptography.CryptoSwiftBatchedCollectionIndex<Base>) -> Swift.Bool where Base : Swift.Collection
}
@usableFromInline
internal struct BatchedCollection<Base> : Swift.Collection where Base : Swift.Collection {
  @usableFromInline
  internal init(base: Base, size: Swift.Int)
  @usableFromInline
  internal typealias Index = cryptography.CryptoSwiftBatchedCollectionIndex<Base>
  @usableFromInline
  internal var startIndex: cryptography.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal var endIndex: cryptography.BatchedCollection<Base>.Index {
    get
  }
  @usableFromInline
  internal func index(after idx: cryptography.BatchedCollection<Base>.Index) -> cryptography.BatchedCollection<Base>.Index
  @usableFromInline
  internal subscript(idx: cryptography.BatchedCollection<Base>.Index) -> Base.SubSequence {
    get
  }
  @usableFromInline
  internal typealias Element = Base.SubSequence
  @usableFromInline
  internal typealias Indices = Swift.DefaultIndices<cryptography.BatchedCollection<Base>>
  @usableFromInline
  internal typealias Iterator = Swift.IndexingIterator<cryptography.BatchedCollection<Base>>
  @usableFromInline
  internal typealias SubSequence = Swift.Slice<cryptography.BatchedCollection<Base>>
}
extension Swift.Collection {
  @inlinable internal func batched(by size: Swift.Int) -> cryptography.BatchedCollection<Self> {
    BatchedCollection(base: self, size: size)
  }
}
public class StringHTTPHandler : cryptography.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: cryptography.HTTPHandlerDelegate)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1Object : Swift.CustomStringConvertible {
  public var rawValue: Foundation.Data?
  public var value: Any?
  public var identifier: cryptography.ASN1Identifier?
  weak public var parent: cryptography.ASN1Object? {
    get
  }
  public func sub(_ index: Swift.Int) -> cryptography.ASN1Object?
  public func subCount() -> Swift.Int
  public func findOid(_ oid: cryptography.OID) -> cryptography.ASN1Object?
  public func findOid(_ oid: Swift.String) -> cryptography.ASN1Object?
  public var description: Swift.String {
    get
  }
  public var asString: Swift.String? {
    get
  }
  @objc deinit
}
public enum CryptoSwiftPKCS7 {
}
public class WSCompression : cryptography.CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: cryptography.FoundationSecurityError, b: cryptography.FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension cryptography.FoundationSecurity : cryptography.CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((cryptography.PinningState) -> ()))
}
extension cryptography.FoundationSecurity : cryptography.HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((cryptography.PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public enum KeyStoreEditorError : Darwin.OSStatus, Swift.Error {
  case unimplemented
  case param
  case allocate
  case notAvailable
  case authFailed
  case duplicateItem
  case itemNotFound
  case interactionNotAllowed
  case decode
  case missingEntitlement
  public static var debugLevel: Swift.Int
  public init?(rawValue: Darwin.OSStatus)
  public typealias RawValue = Darwin.OSStatus
  public var rawValue: Darwin.OSStatus {
    get
  }
}
public protocol CryptoSwiftUpdatable {
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8>
  mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws
}
extension cryptography.CryptoSwiftUpdatable {
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: isLast)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes.slice, isLast: isLast)
  }
  @inlinable public mutating func update(withBytes bytes: Swift.Array<Swift.UInt8>, isLast: Swift.Bool = false, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.update(withBytes: bytes.slice, isLast: isLast, output: output)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: bytes, isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    try self.finish(withBytes: bytes.slice)
  }
  @inlinable public mutating func finish() throws -> Swift.Array<Swift.UInt8> {
    try self.update(withBytes: [], isLast: true)
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    let processed = try update(withBytes: bytes, isLast: true)
    if !processed.isEmpty {
      output(processed)
    }
  }
  @inlinable public mutating func finish(withBytes bytes: Swift.Array<Swift.UInt8>, output: (_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: bytes.slice, output: output)
  }
  @inlinable public mutating func finish(output: (Swift.Array<Swift.UInt8>) -> Swift.Void) throws {
    try self.finish(withBytes: [], output: output)
  }
}
public struct CryptoSwiftECB : cryptography.CryptoSwiftBlockMode {
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init()
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
final public class CryptoSwiftOCB : cryptography.CryptoSwiftBlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: cryptography.CryptoSwiftOCB.Mode, b: cryptography.CryptoSwiftOCB.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: cryptography.CryptoSwiftBlockModeOption
  public enum Error : Swift.Error {
    case invalidNonce
    case fail
    public static func == (a: cryptography.CryptoSwiftOCB.Error, b: cryptography.CryptoSwiftOCB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(nonce N: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: cryptography.CryptoSwiftOCB.Mode = .detached)
  @inlinable convenience public init(nonce N: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: cryptography.CryptoSwiftOCB.Mode = .detached) {
    self.init(nonce: N, additionalAuthenticatedData: additionalAuthenticatedData, tagLength: authenticationTag.count, mode: mode)
    self.authenticationTag = authenticationTag
  }
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
  @objc deinit
}
@_hasMissingDesignatedInitializers open class DH {
  open class DH {
    public init(dhParam: cryptography.DHParam) throws
    open func generateKey() throws -> Foundation.Data
    open func computeKey(_ peerKey: Foundation.Data) throws -> Foundation.Data
    @objc deinit
  }
  public static func available() -> Swift.Bool
  @objc deinit
}
@_inheritsConvenienceInitializers final public class CBCMAC : cryptography.CryptoSwiftCMAC {
  override final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  override public init(key: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(*, deprecated, message: "Use OID instead")
public class ASN1DistinguishedNames {
  final public let oid: Swift.String
  final public let representation: Swift.String
  public static let commonName: cryptography.ASN1DistinguishedNames
  public static let dnQualifier: cryptography.ASN1DistinguishedNames
  public static let serialNumber: cryptography.ASN1DistinguishedNames
  public static let givenName: cryptography.ASN1DistinguishedNames
  public static let surname: cryptography.ASN1DistinguishedNames
  public static let organizationalUnitName: cryptography.ASN1DistinguishedNames
  public static let organizationName: cryptography.ASN1DistinguishedNames
  public static let streetAddress: cryptography.ASN1DistinguishedNames
  public static let localityName: cryptography.ASN1DistinguishedNames
  public static let stateOrProvinceName: cryptography.ASN1DistinguishedNames
  public static let countryName: cryptography.ASN1DistinguishedNames
  public static let email: cryptography.ASN1DistinguishedNames
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ASN1DistinguishedNameFormatter {
  public static var separator: Swift.String
  @objc deinit
}
public enum lastIssueCertInProgressStepEnum {
  case INITIAL
  case KEY_GENERATED
  case CSR_SIGNED
  case CERT_CREATED
  case CERT_IMPORTED
  public static func == (a: cryptography.lastIssueCertInProgressStepEnum, b: cryptography.lastIssueCertInProgressStepEnum) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum KeyConvertError : Swift.Error {
  case invalidKey
  case badPassphrase
  case keyNotEncrypted
  public static var debugLevel: Swift.Int
  public static func == (a: cryptography.KeyConvertError, b: cryptography.KeyConvertError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension cryptography.CryptoSwiftRabbit {
  convenience public init(key: Swift.String) throws
  convenience public init(key: Swift.String, iv: Swift.String) throws
}
@_hasMissingDesignatedInitializers public class X509Extension {
  public var oid: Swift.String? {
    get
  }
  public var name: Swift.String? {
    get
  }
  public var isCritical: Swift.Bool {
    get
  }
  public var value: Any? {
    get
  }
  @objc deinit
}
extension Foundation.Data {
  public func checksum() -> Swift.UInt16
  public func md5() -> Foundation.Data
  public func sha1() -> Foundation.Data
  public func sha224() -> Foundation.Data
  public func sha256() -> Foundation.Data
  public func sha384() -> Foundation.Data
  public func sha512() -> Foundation.Data
  public func sha3(_ variant: cryptography.CryptoSwiftSHA3.Variant) -> Foundation.Data
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Foundation.Data
  public func crc16(seed: Swift.UInt16? = nil) -> Foundation.Data
  public func encrypt(cipher: cryptography.CryptoSwiftCipher) throws -> Foundation.Data
  public func decrypt(cipher: cryptography.CryptoSwiftCipher) throws -> Foundation.Data
  public func authenticate(with authenticator: cryptography.CryptoSwiftAuthenticator) throws -> Foundation.Data
}
extension Foundation.Data {
  public init(hex: Swift.String)
  public var bytesInCryptoSwift: Swift.Array<Swift.UInt8> {
    get
  }
  public func toHexString() -> Swift.String
}
@_hasMissingDesignatedInitializers open class KeyConvertPublicKey {
  public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func pemToPKCS8DER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
  public static func derToPKCS8PEM(_ derKey: Foundation.Data) -> Swift.String
  @objc deinit
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func isSmallPhone(completion: @escaping (Swift.Bool) -> Swift.Void)
  @_Concurrency.MainActor(unsafe) public func anchor(top: UIKit.NSLayoutYAxisAnchor?, left: UIKit.NSLayoutXAxisAnchor?, bottom: UIKit.NSLayoutYAxisAnchor?, right: UIKit.NSLayoutXAxisAnchor?, paddingTop: CoreGraphics.CGFloat, paddingLeft: CoreGraphics.CGFloat, paddingBottom: CoreGraphics.CGFloat, paddingRight: CoreGraphics.CGFloat, width: CoreGraphics.CGFloat, height: CoreGraphics.CGFloat, enableInsets: Swift.Bool)
  @_Concurrency.MainActor(unsafe) public func fadeIn(duration: Foundation.TimeInterval = 1.0)
  @_Concurrency.MainActor(unsafe) public func fadeOut(duration: Foundation.TimeInterval = 1.0)
}
@inlinable internal func rotateLeft(_ value: Swift.UInt8, by: Swift.UInt8) -> Swift.UInt8 {
  ((value << by) & 0xff) | (value >> (8 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  ((value << by) & 0xffff) | (value >> (16 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  ((value << by) & 0xffffffff) | (value >> (32 - by))
}
@inlinable internal func rotateLeft(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  (value << by) | (value >> (64 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt16, by: Swift.UInt16) -> Swift.UInt16 {
  (value >> by) | (value << (16 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt32, by: Swift.UInt32) -> Swift.UInt32 {
  (value >> by) | (value << (32 - by))
}
@inlinable internal func rotateRight(_ value: Swift.UInt64, by: Swift.UInt64) -> Swift.UInt64 {
  ((value >> by) | (value << (64 - by)))
}
@inlinable internal func reversed(_ uint8: Swift.UInt8) -> Swift.UInt8 {
  var v = uint8
  v = (v & 0xf0) >> 4 | (v & 0x0f) << 4
  v = (v & 0xcc) >> 2 | (v & 0x33) << 2
  v = (v & 0xaa) >> 1 | (v & 0x55) << 1
  return v
}
@inlinable internal func reversed(_ uint32: Swift.UInt32) -> Swift.UInt32 {
  var v = uint32
  v = ((v >> 1) & 0x55555555) | ((v & 0x55555555) << 1)
  v = ((v >> 2) & 0x33333333) | ((v & 0x33333333) << 2)
  v = ((v >> 4) & 0x0f0f0f0f) | ((v & 0x0f0f0f0f) << 4)
  v = ((v >> 8) & 0x00ff00ff) | ((v & 0x00ff00ff) << 8)
  v = ((v >> 16) & 0xffff) | ((v & 0xffff) << 16)
  return v
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.ArraySlice<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  return xor(left, right).slice
}
@inlinable internal func xor<T, V>(_ left: T, _ right: V) -> Swift.Array<Swift.UInt8> where T : Swift.RandomAccessCollection, V : Swift.RandomAccessCollection, T.Element == Swift.UInt8, T.Index == Swift.Int, V.Element == Swift.UInt8, V.Index == Swift.Int {
  let length = Swift.min(left.count, right.count)

  let buf = UnsafeMutablePointer<UInt8>.allocate(capacity: length)
  buf.initialize(repeating: 0, count: length)
  defer {
    buf.deinitialize(count: length)
    buf.deallocate()
  }

  // xor
  for i in 0..<length {
    buf[i] = left[left.startIndex.advanced(by: i)] ^ right[right.startIndex.advanced(by: i)]
  }

  return Array(UnsafeBufferPointer(start: buf, count: length))
}
@inline(__always) @inlinable internal func bitPadding(to data: inout Swift.Array<Swift.UInt8>, blockSize: Swift.Int, allowance: Swift.Int = 0) {
  let msgLength = data.count
  // Step 1. Append Padding Bits
  // append one bit (UInt8 with one bit) to message
  data.append(0x80)

  // Step 2. append "0" bit until message length in bits â‰¡ 448 (mod 512)
  let max = blockSize - allowance // 448, 986
  if msgLength % blockSize < max { // 448
    data += Array<UInt8>(repeating: 0, count: max - 1 - (msgLength % blockSize))
  } else {
    data += Array<UInt8>(repeating: 0, count: blockSize + max - 1 - (msgLength % blockSize))
  }
}
public enum CryptoSwiftBit : Swift.Int {
  case zero
  case one
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
extension cryptography.CryptoSwiftBit {
  @inlinable internal func inverted() -> cryptography.CryptoSwiftBit {
    self == .zero ? .one : .zero
  }
}
extension cryptography.X509Certificate {
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class BasicConstraintExtension : cryptography.X509Extension {
    public var isCA: Swift.Bool {
      get
    }
    public var pathLenConstraint: Swift.UInt64? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class SubjectKeyIdentifierExtension : cryptography.X509Extension {
    override public var value: Any? {
      get
    }
    @objc deinit
  }
  public struct AuthorityInfoAccess {
    public let method: Swift.String
    public let location: Swift.String
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthorityInfoAccessExtension : cryptography.X509Extension {
    public var infoAccess: [cryptography.X509Certificate.AuthorityInfoAccess]? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class AuthorityKeyIdentifierExtension : cryptography.X509Extension {
    public var keyIdentifier: Foundation.Data? {
      get
    }
    public var certificateIssuer: [Swift.String]? {
      get
    }
    public var serialNumber: Foundation.Data? {
      get
    }
    @objc deinit
  }
  public struct CertificatePolicyQualifier {
    public let oid: Swift.String
    public let value: Swift.String?
  }
  public struct CertificatePolicy {
    public let oid: Swift.String
    public let qualifiers: [cryptography.X509Certificate.CertificatePolicyQualifier]?
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CertificatePoliciesExtension : cryptography.X509Extension {
    public var policies: [cryptography.X509Certificate.CertificatePolicy]? {
      get
    }
    @objc deinit
  }
  @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class CRLDistributionPointsExtension : cryptography.X509Extension {
    public var crls: [Swift.String]? {
      get
    }
    @objc deinit
  }
}
extension Swift.String {
  @inlinable public var bytesCryptoSwift: Swift.Array<Swift.UInt8> {
    get {
    data(using: String.Encoding.utf8, allowLossyConversion: true)?.bytesInCryptoSwift ?? Array(utf8)
  }
  }
  @inlinable public func md5() -> Swift.String {
    self.bytesCryptoSwift.md5().toHexString()
  }
  @inlinable public func sha1() -> Swift.String {
    self.bytesCryptoSwift.sha1().toHexString()
  }
  @inlinable public func sha224() -> Swift.String {
    self.bytesCryptoSwift.sha224().toHexString()
  }
  @inlinable public func sha256() -> Swift.String {
    self.bytesCryptoSwift.sha256().toHexString()
  }
  @inlinable public func sha384() -> Swift.String {
    self.bytesCryptoSwift.sha384().toHexString()
  }
  @inlinable public func sha512() -> Swift.String {
    self.bytesCryptoSwift.sha512().toHexString()
  }
  @inlinable public func sha3(_ variant: cryptography.CryptoSwiftSHA3.Variant) -> Swift.String {
    self.bytesCryptoSwift.sha3(variant).toHexString()
  }
  @inlinable public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytesCryptoSwift.crc32(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.String {
    self.bytesCryptoSwift.crc32c(seed: seed, reflect: reflect).bytes().toHexString()
  }
  @inlinable public func crc16(seed: Swift.UInt16? = nil) -> Swift.String {
    self.bytesCryptoSwift.crc16(seed: seed).bytes().toHexString()
  }
  @inlinable public func encrypt(cipher: cryptography.CryptoSwiftCipher) throws -> Swift.String {
    try self.bytesCryptoSwift.encrypt(cipher: cipher).toHexString()
  }
  @inlinable public func encryptToBase64(cipher: cryptography.CryptoSwiftCipher) throws -> Swift.String {
    try self.bytesCryptoSwift.encrypt(cipher: cipher).toBase64()
  }
  @inlinable public func authenticate<A>(with authenticator: A) throws -> Swift.String where A : cryptography.CryptoSwiftAuthenticator {
    try self.bytesCryptoSwift.authenticate(with: authenticator).toHexString()
  }
}
final public class CryptoSwiftPoly1305 : cryptography.CryptoSwiftAuthenticator {
  public enum CryptoSwiftError : Swift.Error {
    case authenticateError
    public static func == (a: cryptography.CryptoSwiftPoly1305.CryptoSwiftError, b: cryptography.CryptoSwiftPoly1305.CryptoSwiftError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
final public class CryptoSwiftAES {
  public enum Error : Swift.Error {
    case invalidKeySize
    case dataPaddingRequired
    case invalidData
    public static func == (a: cryptography.CryptoSwiftAES.Error, b: cryptography.CryptoSwiftAES.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant : Swift.Int {
    case aes128, aes192, aes256
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  @usableFromInline
  final internal let variantNr: Swift.Int
  @usableFromInline
  final internal let variantNb: Swift.Int
  @usableFromInline
  final internal let variantNk: Swift.Int
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  final public let variant: cryptography.CryptoSwiftAES.Variant
  @usableFromInline
  final internal let blockMode: cryptography.CryptoSwiftBlockMode
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  final internal var expandedKey: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  final internal var expandedKeyInv: Swift.Array<Swift.Array<Swift.UInt32>> {
    get
    set
  }
  @usableFromInline
  internal static let T0: [Swift.UInt32]
  @usableFromInline
  internal static let T0_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T1: [Swift.UInt32]
  @usableFromInline
  internal static let T1_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T2: [Swift.UInt32]
  @usableFromInline
  internal static let T2_INV: [Swift.UInt32]
  @usableFromInline
  internal static let T3: [Swift.UInt32]
  @usableFromInline
  internal static let T3_INV: [Swift.UInt32]
  @usableFromInline
  internal static let U1: [Swift.UInt32]
  @usableFromInline
  internal static let U2: [Swift.UInt32]
  @usableFromInline
  internal static let U3: [Swift.UInt32]
  @usableFromInline
  internal static let U4: [Swift.UInt32]
  public init(key: Swift.Array<Swift.UInt8>, blockMode: cryptography.CryptoSwiftBlockMode, padding: cryptography.CryptoSwiftPadding = .pkcs7) throws
  @inlinable final internal func encrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>? {
    if self.blockMode.options.contains(.paddingRequired) && block.count != CryptoSwiftAES.blockSize {
      return Array(block)
    }

    let rounds = self.variantNr
    let rk = self.expandedKey

    let b00 = UInt32(block[block.startIndex.advanced(by: 0)])
    let b01 = UInt32(block[block.startIndex.advanced(by: 1)]) << 8
    let b02 = UInt32(block[block.startIndex.advanced(by: 2)]) << 16
    let b03 = UInt32(block[block.startIndex.advanced(by: 3)]) << 24
    var b0 = b00 | b01 | b02 | b03

    let b10 = UInt32(block[block.startIndex.advanced(by: 4)])
    let b11 = UInt32(block[block.startIndex.advanced(by: 5)]) << 8
    let b12 = UInt32(block[block.startIndex.advanced(by: 6)]) << 16
    let b13 = UInt32(block[block.startIndex.advanced(by: 7)]) << 24
    var b1 = b10 | b11 | b12 | b13

    let b20 = UInt32(block[block.startIndex.advanced(by: 8)])
    let b21 = UInt32(block[block.startIndex.advanced(by: 9)]) << 8
    let b22 = UInt32(block[block.startIndex.advanced(by: 10)]) << 16
    let b23 = UInt32(block[block.startIndex.advanced(by: 11)]) << 24
    var b2 = b20 | b21 | b22 | b23

    let b30 = UInt32(block[block.startIndex.advanced(by: 12)])
    let b31 = UInt32(block[block.startIndex.advanced(by: 13)]) << 8
    let b32 = UInt32(block[block.startIndex.advanced(by: 14)]) << 16
    let b33 = UInt32(block[block.startIndex.advanced(by: 15)]) << 24
    var b3 = b30 | b31 | b32 | b33

    let tLength = 4
    let t = UnsafeMutablePointer<UInt32>.allocate(capacity: tLength)
    t.initialize(repeating: 0, count: tLength)
    defer {
      t.deinitialize(count: tLength)
      t.deallocate()
    }

    for r in 0..<rounds - 1 {
      t[0] = b0 ^ rk[r][0]
      t[1] = b1 ^ rk[r][1]
      t[2] = b2 ^ rk[r][2]
      t[3] = b3 ^ rk[r][3]

      let lb00 = CryptoSwiftAES.T0[Int(t[0] & 0xff)]
      let lb01 = CryptoSwiftAES.T1[Int((t[1] >> 8) & 0xff)]
      let lb02 = CryptoSwiftAES.T2[Int((t[2] >> 16) & 0xff)]
      let lb03 = CryptoSwiftAES.T3[Int(t[3] >> 24)]
      b0 = lb00 ^ lb01 ^ lb02 ^ lb03

      let lb10 = CryptoSwiftAES.T0[Int(t[1] & 0xff)]
      let lb11 = CryptoSwiftAES.T1[Int((t[2] >> 8) & 0xff)]
      let lb12 = CryptoSwiftAES.T2[Int((t[3] >> 16) & 0xff)]
      let lb13 = CryptoSwiftAES.T3[Int(t[0] >> 24)]
      b1 = lb10 ^ lb11 ^ lb12 ^ lb13

      let lb20 = CryptoSwiftAES.T0[Int(t[2] & 0xff)]
      let lb21 = CryptoSwiftAES.T1[Int((t[3] >> 8) & 0xff)]
      let lb22 = CryptoSwiftAES.T2[Int((t[0] >> 16) & 0xff)]
      let lb23 = CryptoSwiftAES.T3[Int(t[1] >> 24)]
      b2 = lb20 ^ lb21 ^ lb22 ^ lb23

      let lb30 = CryptoSwiftAES.T0[Int(t[3] & 0xff)]
      let lb31 = CryptoSwiftAES.T1[Int((t[0] >> 8) & 0xff)]
      let lb32 = CryptoSwiftAES.T2[Int((t[1] >> 16) & 0xff)]
      let lb33 = CryptoSwiftAES.T3[Int(t[2] >> 24)]
      b3 = lb30 ^ lb31 ^ lb32 ^ lb33
    }

    // last round
    let r = rounds - 1

    t[0] = b0 ^ rk[r][0]
    t[1] = b1 ^ rk[r][1]
    t[2] = b2 ^ rk[r][2]
    t[3] = b3 ^ rk[r][3]

    // rounds
    b0 = F1(t[0], t[1], t[2], t[3]) ^ rk[rounds][0]
    b1 = F1(t[1], t[2], t[3], t[0]) ^ rk[rounds][1]
    b2 = F1(t[2], t[3], t[0], t[1]) ^ rk[rounds][2]
    b3 = F1(t[3], t[0], t[1], t[2]) ^ rk[rounds][3]

    let encrypted: Array<UInt8> = [
      UInt8(b0 & 0xff), UInt8((b0 >> 8) & 0xff), UInt8((b0 >> 16) & 0xff), UInt8((b0 >> 24) & 0xff),
      UInt8(b1 & 0xff), UInt8((b1 >> 8) & 0xff), UInt8((b1 >> 16) & 0xff), UInt8((b1 >> 24) & 0xff),
      UInt8(b2 & 0xff), UInt8((b2 >> 8) & 0xff), UInt8((b2 >> 16) & 0xff), UInt8((b2 >> 24) & 0xff),
      UInt8(b3 & 0xff), UInt8((b3 >> 8) & 0xff), UInt8((b3 >> 16) & 0xff), UInt8((b3 >> 24) & 0xff)
    ]
    return encrypted
  }
  @usableFromInline
  final internal func decrypt(block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
  @objc deinit
}
extension cryptography.CryptoSwiftAES {
  @usableFromInline
  @inline(__always) final internal func F1(_ x0: Swift.UInt32, _ x1: Swift.UInt32, _ x2: Swift.UInt32, _ x3: Swift.UInt32) -> Swift.UInt32
}
extension cryptography.CryptoSwiftAES : cryptography.CryptoSwiftCipher {
  @inlinable final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    let blockSize = self.blockMode.customBlockSize ?? CryptoSwiftAES.blockSize
    let chunks = bytes.batched(by: blockSize)

    var oneTimeCryptor = try makeEncryptor()
    var out = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in chunks {
      out += try oneTimeCryptor.update(withBytes: chunk, isLast: false)
    }
    // Padding may be added at the very end
    out += try oneTimeCryptor.finish()

    if self.blockMode.options.contains(.paddingRequired) && (out.count % CryptoSwiftAES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    return out
  }
  @inlinable final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8> {
    if self.blockMode.options.contains(.paddingRequired) && (bytes.count % CryptoSwiftAES.blockSize != 0) {
      throw Error.dataPaddingRequired
    }

    var oneTimeCryptor = try makeDecryptor()
    let chunks = bytes.batched(by: CryptoSwiftAES.blockSize)
    if chunks.isEmpty {
      throw Error.invalidData
    }

    var out = Array<UInt8>(reserveCapacity: bytes.count)

    var lastIdx = chunks.startIndex
    chunks.indices.formIndex(&lastIdx, offsetBy: chunks.count - 1)

    // To properly remove padding, `isLast` has to be known when called with the last chunk of ciphertext
    // Last chunk of ciphertext may contains padded data so next call to update(..) won't be able to remove it
    for idx in chunks.indices {
      out += try oneTimeCryptor.update(withBytes: chunks[idx], isLast: idx == lastIdx)
    }
    return out
  }
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: cryptography.ErrorType, b: cryptography.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: cryptography.ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: cryptography.ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension cryptography.WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: cryptography.WebSocketEvent, client: cryptography.WebSocketClient)
}
open class WebSocket : cryptography.WebSocketClient, cryptography.EngineDelegate {
  weak public var delegate: cryptography.WebSocketDelegate?
  public var onEvent: ((cryptography.WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set
  }
  public init(request: Foundation.URLRequest, engine: cryptography.Engine)
  convenience public init(request: Foundation.URLRequest, certPinner: cryptography.CertificatePinning? = FoundationSecurity(), compressionHandler: cryptography.CompressionHandler? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: cryptography.WebSocketEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class GCM {
  public static func crypt(_ opMode: cryptography.OpMode, algorithm: cryptography.Algorithm, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, aData: Foundation.Data, tagLength: Swift.Int) throws -> (Foundation.Data, Foundation.Data)
  public static func available() -> Swift.Bool
  @objc deinit
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: cryptography.FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: cryptography.Frame)
  @objc deinit
}
public enum DHParam {
  case rfc3526Group5
  case rfc2409Group2
  public static func == (a: cryptography.DHParam, b: cryptography.DHParam) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class CryptoSwiftCMAC : cryptography.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case wrongKeyLength
    public static func == (a: cryptography.CryptoSwiftCMAC.Error, b: cryptography.CryptoSwiftCMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(key: Swift.Array<Swift.UInt8>) throws
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func authenticate(_ bytes: Swift.Array<Swift.UInt8>, cipher: cryptography.CryptoSwiftCipher) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension cryptography.Blowfish {
  convenience public init(key: Swift.String, iv: Swift.String, padding: cryptography.CryptoSwiftPadding = .pkcs7) throws
}
final public class CryptoSwiftSHA1 {
  @usableFromInline
  internal static let digestLength: Swift.Int
  @usableFromInline
  internal static let blockSize: Swift.Int
  @usableFromInline
  internal static let hashInitialValue: Swift.ContiguousArray<Swift.UInt32>
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var processedBytesTotalCount: Swift.Int
  @usableFromInline
  final internal var accumulatedHash: Swift.ContiguousArray<Swift.UInt32>
  public init()
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt8>, currentHash hh: inout Swift.ContiguousArray<Swift.UInt32>)
  @objc deinit
}
extension cryptography.CryptoSwiftSHA1 : cryptography.CryptoSwiftUpdatable {
  @discardableResult
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      let lengthInBits = (processedBytesTotalCount + self.accumulated.count) * 8
      let lengthBytes = lengthInBits.bytes(totalBytes: 64 / 8) // A 64-bit representation of b

      // Step 1. Append padding
      bitPadding(to: &self.accumulated, blockSize: CryptoSwiftSHA1.blockSize, allowance: 64 / 8)

      // Step 2. Append Length a 64-bit representation of lengthInBits
      self.accumulated += lengthBytes
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: CryptoSwiftSHA1.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= CryptoSwiftSHA1.blockSize {
        self.process(block: chunk, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)
    self.processedBytesTotalCount += processedBytes

    // output current hash
    var result = Array<UInt8>(repeating: 0, count: CryptoSwiftSHA1.digestLength)
    var pos = 0
    for idx in 0..<self.accumulatedHash.count {
      let h = self.accumulatedHash[idx]
      result[pos + 0] = UInt8((h >> 24) & 0xff)
      result[pos + 1] = UInt8((h >> 16) & 0xff)
      result[pos + 2] = UInt8((h >> 8) & 0xff)
      result[pos + 3] = UInt8(h & 0xff)
      pos += 4
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = CryptoSwiftSHA1.hashInitialValue
    }

    return result
  }
}
public enum OID : Swift.String {
  case etsiQcsCompliance
  case etsiQcsRetentionPeriod
  case etsiQcsQcSSCD
  case dsa
  case ecPublicKey
  case prime256v1
  case ecdsaWithSHA256
  case ecdsaWithSHA512
  case rsaEncryption
  case sha256WithRSAEncryption
  case md5WithRSAEncryption
  case sha1WithRSAEncryption
  case sha1
  case pkcsSha256
  case sha2Family
  case sha3_244
  case sha3_256
  case sha3_384
  case md5
  case pkcs7data
  case pkcs7signedData
  case pkcs7envelopedData
  case emailAddress
  case signingCertificateV2
  case contentType
  case messageDigest
  case signingTime
  case certificateExtension
  case jurisdictionLocalityName
  case jurisdictionStateOrProvinceName
  case jurisdictionCountryName
  case authorityInfoAccess
  case qcStatements
  case cps
  case unotice
  case serverAuth
  case clientAuth
  case ocsp
  case caIssuers
  case dateOfBirth
  case sha256
  case VeriSignEVpolicy
  case extendedValidation
  case organizationValidated
  case subjectKeyIdentifier
  case keyUsage
  case subjectAltName
  case issuerAltName
  case basicConstraints
  case cRLDistributionPoints
  case certificatePolicies
  case authorityKeyIdentifier
  case extKeyUsage
  case subjectDirectoryAttributes
  case commonName
  case surname
  case serialNumber
  case countryName
  case localityName
  case stateOrProvinceName
  case streetAddress
  case organizationName
  case organizationalUnitName
  case businessCategory
  case postalCode
  case givenName
  case dnQualifier
  case domainComponent
  case userId
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct CryptoSwiftPCBC : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftPCBC.Error, b: cryptography.CryptoSwiftPCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
@_specialize(exported: false, kind: full, where T == Swift.Int)
@_specialize(exported: false, kind: full, where T == Swift.UInt)
@_specialize(exported: false, kind: full, where T == Swift.UInt8)
@_specialize(exported: false, kind: full, where T == Swift.UInt16)
@_specialize(exported: false, kind: full, where T == Swift.UInt32)
@_specialize(exported: false, kind: full, where T == Swift.UInt64)
@inlinable internal func arrayOfBytes<T>(value: T, length totalBytes: Swift.Int = MemoryLayout<T>.size) -> Swift.Array<Swift.UInt8> where T : Swift.FixedWidthInteger {
  let valuePointer = UnsafeMutablePointer<T>.allocate(capacity: 1)
  valuePointer.pointee = value

  let bytesPointer = UnsafeMutablePointer<UInt8>(OpaquePointer(valuePointer))
  var bytes = Array<UInt8>(repeating: 0, count: totalBytes)
  for j in 0..<min(MemoryLayout<T>.size, totalBytes) {
    bytes[totalBytes - 1 - j] = (bytesPointer + j).pointee
  }

  valuePointer.deinitialize(count: 1)
  valuePointer.deallocate()

  return bytes
}
public struct CryptoSwiftHKDF {
  public enum Error : Swift.Error {
    case invalidInput
    case derivedKeyTooLong
    public static func == (a: cryptography.CryptoSwiftHKDF.Error, b: cryptography.CryptoSwiftHKDF.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>? = nil, info: Swift.Array<Swift.UInt8>? = nil, keyLength: Swift.Int? = nil, variant: cryptography.CryptoSwiftHMAC.Variant = .sha2(.sha256)) throws
  public func calculate() throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.CryptoSwiftPKCS5 {
  public struct PBKDF2 {
    public enum Error : Swift.Error {
      case invalidInput
      case derivedKeyTooLong
      public static func == (a: cryptography.CryptoSwiftPKCS5.PBKDF2.Error, b: cryptography.CryptoSwiftPKCS5.PBKDF2.Error) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
    public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, iterations: Swift.Int = 4096, keyLength: Swift.Int? = nil, variant: cryptography.CryptoSwiftHMAC.Variant = .sha2(.sha256)) throws
    public func calculate() throws -> Swift.Array<Swift.UInt8>
  }
}
extension cryptography.CryptoSwiftHMAC {
  convenience public init(key: Swift.String, variant: cryptography.CryptoSwiftHMAC.Variant = .md5) throws
}
extension Swift.UInt64 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt64(bytes[index.advanced(by: 0)]) << 56 : 0
    let val1 = count > 1 ? UInt64(bytes[index.advanced(by: 1)]) << 48 : 0
    let val2 = count > 2 ? UInt64(bytes[index.advanced(by: 2)]) << 40 : 0
    let val3 = count > 3 ? UInt64(bytes[index.advanced(by: 3)]) << 32 : 0
    let val4 = count > 4 ? UInt64(bytes[index.advanced(by: 4)]) << 24 : 0
    let val5 = count > 5 ? UInt64(bytes[index.advanced(by: 5)]) << 16 : 0
    let val6 = count > 6 ? UInt64(bytes[index.advanced(by: 6)]) << 8 : 0
    let val7 = count > 7 ? UInt64(bytes[index.advanced(by: 7)]) : 0

    self = val0 | val1 | val2 | val3 | val4 | val5 | val6 | val7
  }
}
@_hasMissingDesignatedInitializers public class ASN1DERDecoder {
  public static func decode(data: Foundation.Data) throws -> [cryptography.ASN1Object]
  @objc deinit
}
extension Foundation.Data {
  public var uint64Value: Swift.UInt64? {
    get
  }
}
extension Foundation.Data {
  public var sequenceContent: Foundation.Data {
    get
  }
}
@_hasMissingDesignatedInitializers public class X509Certificate : Swift.CustomStringConvertible {
  convenience public init(data: Foundation.Data) throws
  public init(der: Foundation.Data) throws
  convenience public init(pem: Foundation.Data) throws
  public var description: Swift.String {
    get
  }
  public func checkValidity(_ date: Foundation.Date = Date()) -> Swift.Bool
  public var version: Swift.Int? {
    get
  }
  public var serialNumber: Foundation.Data? {
    get
  }
  public var issuerDistinguishedName: Swift.String? {
    get
  }
  public var issuerOIDs: [Swift.String] {
    get
  }
  public func issuer(oidString: Swift.String) -> Swift.String?
  public func issuer(oid: cryptography.OID) -> Swift.String?
  @available(*, deprecated, message: "Use issuer(oid:) instead")
  public func issuer(dn: cryptography.ASN1DistinguishedNames) -> Swift.String?
  public var subjectDistinguishedName: Swift.String? {
    get
  }
  public var subjectOIDs: [Swift.String] {
    get
  }
  public func subject(oidString: Swift.String) -> [Swift.String]?
  public func subject(oid: cryptography.OID) -> [Swift.String]?
  @available(*, deprecated, message: "Use subject(oid:) instead")
  public func subject(dn: cryptography.ASN1DistinguishedNames) -> [Swift.String]?
  public var notBefore: Foundation.Date? {
    get
  }
  public var notAfter: Foundation.Date? {
    get
  }
  public var signature: Foundation.Data? {
    get
  }
  public var sigAlgName: Swift.String? {
    get
  }
  public var sigAlgOID: Swift.String? {
    get
  }
  public var sigAlgParams: Foundation.Data? {
    get
  }
  public var keyUsage: [Swift.Bool] {
    get
  }
  public var extendedKeyUsage: [Swift.String] {
    get
  }
  public var subjectAlternativeNames: [Swift.String] {
    get
  }
  public var issuerAlternativeNames: [Swift.String] {
    get
  }
  public var publicKey: cryptography.X509PublicKey? {
    get
  }
  public var publicKeyPEM: Swift.String? {
    get
  }
  public func toPEM(_ derKey: Foundation.Data) -> Swift.String
  public func base64Decode(_ base64Data: Swift.String) -> Foundation.Data?
  public func base64Encode(_ key: Foundation.Data) -> Swift.String
  public var criticalExtensionOIDs: [Swift.String] {
    get
  }
  public var nonCriticalExtensionOIDs: [Swift.String] {
    get
  }
  public func extensionObject(oid: cryptography.OID) -> cryptography.X509Extension?
  public func extensionObject(oid: Swift.String) -> cryptography.X509Extension?
  @objc deinit
}
final public class CryptoSwiftScrypt {
  public init(password: Swift.Array<Swift.UInt8>, salt: Swift.Array<Swift.UInt8>, dkLen: Swift.Int, N: Swift.Int, r: Swift.Int, p: Swift.Int) throws
  final public func calculate() throws -> [Swift.UInt8]
  @objc deinit
}
public enum HMACAlg : cryptography.CC.CCHmacAlgorithm {
  case sha1, md5, sha256, sha384, sha512, sha224
  public init?(rawValue: cryptography.CC.CCHmacAlgorithm)
  public typealias RawValue = cryptography.CC.CCHmacAlgorithm
  public var rawValue: cryptography.CC.CCHmacAlgorithm {
    get
  }
}
public struct PersianDatePickerPresenter {
  public init()
  public func show(in viewController: UIKit.UIViewController, callBack: @escaping (_ persianDate: Swift.String) -> ())
}
public enum OpMode : cryptography.CC.CCOperation {
  case encrypt, decrypt
  public init?(rawValue: cryptography.CC.CCOperation)
  public typealias RawValue = cryptography.CC.CCOperation
  public var rawValue: cryptography.CC.CCOperation {
    get
  }
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: cryptography.TCPTransportError, b: cryptography.TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : cryptography.Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: cryptography.CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: cryptography.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc deinit
}
public enum CipherError : Swift.Error {
  case encrypt
  case decrypt
  public static func == (a: cryptography.CipherError, b: cryptography.CipherError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol CryptoSwiftCipher : AnyObject {
  var keySize: Swift.Int { get }
  func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.CryptoSwiftCipher {
  public func encrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  public func decrypt(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.String {
  public func decryptBase64ToString(cipher: cryptography.CryptoSwiftCipher) throws -> Swift.String
  public func decryptBase64(cipher: cryptography.CryptoSwiftCipher) throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.PKCS7 {
  public var signatures: [cryptography.SignatureInfo]? {
    get
  }
}
public class SignatureInfo {
  final public let version: cryptography.ASN1Object?
  final public let signerIdentifier: cryptography.ASN1Object?
  final public let digestAlgorithmIdentifier: cryptography.ASN1Object?
  final public let signedAttributes: cryptography.ASN1Object?
  final public let signatureAlgorithm: cryptography.ASN1Object?
  final public let signature: cryptography.ASN1Object?
  public var signatureData: Foundation.Data? {
    get
  }
  public var disgestAlgorithmName: Swift.String? {
    get
  }
  public var digestAlgorithmOID: cryptography.OID? {
    get
  }
  public var signatureAlgorithmName: Swift.String? {
    get
  }
  public var signatureAlgorithmOID: cryptography.OID? {
    get
  }
  public init(asn1: cryptography.ASN1Object)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : cryptography.HTTPServerHandler {
  public func register(delegate: cryptography.HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public typealias CipherOperationOnBlock = (_ block: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>?
public protocol CryptoSwiftBlockMode {
  var options: cryptography.CryptoSwiftBlockModeOption { get }
  @inlinable func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
  var customBlockSize: Swift.Int? { get }
}
@_hasMissingDesignatedInitializers open class CRC {
  public typealias CNcrc = Swift.UInt32
  public enum Mode : cryptography.CRC.CNcrc {
    case crc8, crc8ICODE, crc8ITU, crc8ROHC, crc8WCDMA, crc16, crc16CCITTTrue, crc16CCITTFalse, crc16USB, crc16XMODEM, crc16DECTR, crc16DECTX, crc16ICODE, crc16VERIFONE, crc16A, crc16B, crc16Fletcher, crc32Adler, crc32, crc32CASTAGNOLI, crc32BZIP2, crc32MPEG2, crc32POSIX, crc32XFER, crc64ECMA182
    public init?(rawValue: cryptography.CRC.CNcrc)
    public typealias RawValue = cryptography.CRC.CNcrc
    public var rawValue: cryptography.CRC.CNcrc {
      get
    }
  }
  public static func crc(_ input: Foundation.Data, mode: cryptography.CRC.Mode) throws -> Swift.UInt64
  public static func available() -> Swift.Bool
  @objc deinit
}
@usableFromInline
final internal class CryptoSwiftStreamDecryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: cryptography.CryptoSwiftCipherModeWorker
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: cryptography.CryptoSwiftCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    let toProcess = self.accumulated.prefix(max(self.accumulated.count - self.worker.additionalBufferSize, 0))

    if var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker, isLast == true {
      // will truncate suffix if needed
      try finalizingWorker.willDecryptLast(bytes: self.accumulated.slice)
    }

    var processedBytesCount = 0
    var plaintext = Array<UInt8>(reserveCapacity: bytes.count + self.worker.additionalBufferSize)
    for chunk in toProcess.batched(by: self.blockSize) {
      plaintext += self.worker.decrypt(block: chunk)
      processedBytesCount += chunk.count
    }

    if var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.didDecryptLast(bytes: plaintext.slice))
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = plaintext.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      plaintext = self.padding.remove(from: plaintext, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    self.accumulated.removeFirst(processedBytesCount) // super-slow

    if var finalizingWorker = worker as? CryptoSwiftFinalizingDecryptModeWorker, isLast == true {
      plaintext = Array(try finalizingWorker.finalize(decrypt: plaintext.slice))
    }

    return plaintext
  }
  @inlinable final public func seek(to position: Swift.Int) throws {
    guard var worker = self.worker as? CryptoSwiftSeekableModeWorker else {
      fatalError("Not supported")
    }

    try worker.seek(to: position)
    self.worker = worker
  }
  @objc @usableFromInline
  deinit
}
@_hasMissingDesignatedInitializers open class PKCS8PrivateKey {
  public static func getPKCS1DEROffset(_ derKey: Foundation.Data) -> Swift.Int?
  public static func stripHeaderIfAny(_ derKey: Foundation.Data) -> Foundation.Data?
  public static func hasCorrectHeader(_ derKey: Foundation.Data) -> Swift.Bool
  @objc deinit
}
public class Crypto {
  public init()
  public func setRestApiToken(token: Swift.String)
  public func getRestApiToken() -> Swift.String?
  public func setSocketToken(token: Swift.String)
  public func generateKeys(type: cryptography.KeyType) -> (publicKey: Swift.String, modulus: Swift.String, exponent: Swift.String, keyAlias: Swift.String)
  public func generateAndReturnKeys(type: cryptography.KeyType) -> (publicKeyAsString: Swift.String, publicKeyAsData: Foundation.Data, privateKeyAsString: Swift.String, privateKeyAsData: Foundation.Data, modulus: Swift.String, exponent: Swift.String, keyTag: Swift.String)
  public func sign(keyId: Swift.String, hexString: Swift.String, signitureType: cryptography.SignitureType, privateKey: Foundation.Data) -> Foundation.Data?
  public func sign1(keyAlias: Swift.String, data: Foundation.Data, signitureType: cryptography.SignitureType) -> Foundation.Data?
  public func signByHMAC(data: Swift.String, keyHMAC: Foundation.Data) -> Swift.String?
  public func signByHMAC(data: Swift.Array<Swift.UInt8>, keyHMAC: Foundation.Data) -> Swift.String?
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PEMPublicKey {
  public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
  public static func addHeader(_ base64: Swift.String) -> Swift.String
  @objc deinit
}
public struct DeleteKeyResponse : Swift.Codable {
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
@_hasMissingDesignatedInitializers open class PEMPrivateKey {
  public static func toDER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func toPEM(_ derKey: Foundation.Data) -> Swift.String
  public static func addHeader(_ base64: Swift.String) -> Swift.String
  public static func addRSAHeader(_ base64: Swift.String) -> Swift.String
  public static func stripHeader(_ pemKey: Swift.String) -> Swift.String?
  @objc deinit
}
@usableFromInline
final internal class CryptoSwiftStreamEncryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
  @usableFromInline
  final internal let blockSize: Swift.Int
  @usableFromInline
  final internal var worker: cryptography.CryptoSwiftCipherModeWorker
  @usableFromInline
  final internal let padding: cryptography.CryptoSwiftPadding
  @usableFromInline
  final internal var lastBlockRemainder: Swift.Int
  @usableFromInline
  internal init(blockSize: Swift.Int, padding: cryptography.CryptoSwiftPadding, _ worker: cryptography.CryptoSwiftCipherModeWorker) throws
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool) throws -> Swift.Array<Swift.UInt8> {
    var accumulated = Array(bytes)
    if isLast {
      // CTR doesn't need padding. Really. Add padding to the last block if really want. but... don't.
      accumulated = self.padding.add(to: accumulated, blockSize: self.blockSize - self.lastBlockRemainder)
    }

    var encrypted = Array<UInt8>(reserveCapacity: bytes.count)
    for chunk in accumulated.batched(by: self.blockSize) {
      encrypted += self.worker.encrypt(block: chunk)
    }

    // omit unecessary calculation if not needed
    if self.padding != .noPadding {
      self.lastBlockRemainder = encrypted.count.quotientAndRemainder(dividingBy: self.blockSize).remainder
    }

    if var finalizingWorker = worker as? CryptoSwiftFinalizingEncryptModeWorker, isLast == true {
      encrypted = Array(try finalizingWorker.finalize(encrypt: encrypted.slice))
    }

    return encrypted
  }
  @usableFromInline
  final internal func seek(to: Swift.Int) throws
  @objc @usableFromInline
  deinit
}
extension Swift.UInt32 {
  @_specialize(exported: false, kind: full, where T == Swift.ArraySlice<Swift.UInt8>)
  @inlinable internal init<T>(bytes: T, fromIndex index: T.Index) where T : Swift.Collection, T.Element == Swift.UInt8, T.Index == Swift.Int {
    if bytes.isEmpty {
      self = 0
      return
    }

    let count = bytes.count

    let val0 = count > 0 ? UInt32(bytes[index.advanced(by: 0)]) << 24 : 0
    let val1 = count > 1 ? UInt32(bytes[index.advanced(by: 1)]) << 16 : 0
    let val2 = count > 2 ? UInt32(bytes[index.advanced(by: 2)]) << 8 : 0
    let val3 = count > 3 ? UInt32(bytes[index.advanced(by: 3)]) : 0

    self = val0 | val1 | val2 | val3
  }
}
public struct CryptoSwiftBlockModeOption : Swift.OptionSet {
  public let rawValue: Swift.Int
  public init(rawValue: Swift.Int)
  @usableFromInline
  internal static let none: cryptography.CryptoSwiftBlockModeOption
  @usableFromInline
  internal static let initializationVectorRequired: cryptography.CryptoSwiftBlockModeOption
  @usableFromInline
  internal static let paddingRequired: cryptography.CryptoSwiftBlockModeOption
  @usableFromInline
  internal static let useEncryptToDecrypt: cryptography.CryptoSwiftBlockModeOption
  public typealias ArrayLiteralElement = cryptography.CryptoSwiftBlockModeOption
  public typealias Element = cryptography.CryptoSwiftBlockModeOption
  public typealias RawValue = Swift.Int
}
public enum Padding : cryptography.CC.CCPadding {
  case noPadding, pkcs7Padding
  public init?(rawValue: cryptography.CC.CCPadding)
  public typealias RawValue = cryptography.CC.CCPadding
  public var rawValue: cryptography.CC.CCPadding {
    get
  }
}
@_hasMissingDesignatedInitializers open class CMAC {
  public static func AESCMAC(_ data: Foundation.Data, key: Foundation.Data) -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
public protocol CryptoSwiftAuthenticator {
  func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : cryptography.Server, cryptography.ConnectionDelegate {
  public var onEvent: ((cryptography.ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
  public func didReceive(event: cryptography.ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : cryptography.Connection, cryptography.HTTPServerDelegate, cryptography.FramerEventClient, cryptography.FrameCollectorDelegate, cryptography.TransportEventClient {
  public var onEvent: ((cryptography.ConnectionEvent) -> Swift.Void)?
  weak public var delegate: cryptography.ConnectionDelegate?
  public func write(data: Foundation.Data, opcode: cryptography.FrameOpCode)
  public func connectionChanged(state: cryptography.ConnectionState)
  public func didReceive(event: cryptography.HTTPEvent)
  public func frameProcessed(event: cryptography.FrameEvent)
  public func didForm(event: cryptography.FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
@available(*, renamed: "Digest")
public typealias CryptoSwiftHash = cryptography.CryptoSwiftDigest
public struct CryptoSwiftDigest {
  public static func md5(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha1(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha224(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha256(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha384(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha512(_ bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  public static func sha2(_ bytes: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftSHA2.Variant) -> Swift.Array<Swift.UInt8>
  public static func sha3(_ bytes: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftSHA3.Variant) -> Swift.Array<Swift.UInt8>
}
public enum Algorithm : cryptography.CC.CCAlgorithm {
  case aes, des, threeDES, cast, rc4, rc2, blowfish
  public init?(rawValue: cryptography.CC.CCAlgorithm)
  public typealias RawValue = cryptography.CC.CCAlgorithm
  public var rawValue: cryptography.CC.CCAlgorithm {
    get
  }
}
public enum AuthBlockMode : cryptography.CC.CCMode {
  case gcm, ccm
  public init?(rawValue: cryptography.CC.CCMode)
  public typealias RawValue = cryptography.CC.CCMode
  public var rawValue: cryptography.CC.CCMode {
    get
  }
}
public struct CryptoSwiftCCM {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case invalidParameter
    case fail
    public static func == (a: cryptography.CryptoSwiftCCM.Error, b: cryptography.CryptoSwiftCCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public init(iv: Swift.Array<Swift.UInt8>, tagLength: Swift.Int, messageLength: Swift.Int, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) public class PersianDatePickerView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public var year: Swift.Int
  @_Concurrency.MainActor(unsafe) public var month: Swift.Int
  @_Concurrency.MainActor(unsafe) public var day: Swift.Int
  @_Concurrency.MainActor(unsafe) public var onChange: (cryptography.Listener)?
  @_Concurrency.MainActor(unsafe) public var font: UIKit.UIFont?
  @_Concurrency.MainActor(unsafe) public var style: cryptography.PersianDatePickerStyle {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) convenience public init(date: Foundation.Date, timeZone: Foundation.TimeZone? = nil)
  @_Concurrency.MainActor(unsafe) public func setYearsRange(fromYear: Swift.Int, toYear: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setMaxYear(toYear: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func setMinYear(fromYear: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func gotoCurrentDate()
  @_Concurrency.MainActor(unsafe) public func gotoDate(date: Foundation.Date)
  @_Concurrency.MainActor(unsafe) public func setPersianDate(year: Swift.Int, month: Swift.Int, day: Swift.Int)
  @_Concurrency.MainActor(unsafe) public func getGregorianDate() -> Foundation.Date?
  @_Concurrency.MainActor(unsafe) public func getPersianDate() -> Swift.String?
  @_Concurrency.MainActor(unsafe) public func nextDay(by date: Swift.String)
  @_Concurrency.MainActor(unsafe) public func backDay(by date: Swift.String)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @objc deinit
}
extension cryptography.PersianDatePickerView : UIKit.UIPickerViewDataSource {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func numberOfComponents(in pickerView: UIKit.UIPickerView) -> Swift.Int
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, numberOfRowsInComponent component: Swift.Int) -> Swift.Int
}
extension cryptography.PersianDatePickerView : UIKit.UIPickerViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, viewForRow row: Swift.Int, forComponent component: Swift.Int, reusing view: UIKit.UIView?) -> UIKit.UIView
  @_Concurrency.MainActor(unsafe) @objc dynamic public func pickerView(_ pickerView: UIKit.UIPickerView, didSelectRow row: Swift.Int, inComponent component: Swift.Int)
}
public typealias Listener = (_ year: Swift.Int, _ month: Swift.Int, _ day: Swift.Int) -> Swift.Void
public enum PersianDatePickerStyle {
  case short
  case long
  public static func == (a: cryptography.PersianDatePickerStyle, b: cryptography.PersianDatePickerStyle) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct CryptoSwiftCFB : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftCFB.Error, b: cryptography.CryptoSwiftCFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum SegmentSize : Swift.Int {
    case cfb8
    case cfb128
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>, segmentSize: cryptography.CryptoSwiftCFB.SegmentSize = .cfb128)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
final public class Blowfish {
  public enum Error : Swift.Error {
    case dataPaddingRequired
    case invalidKeyOrInitializationVector
    case invalidInitializationVector
    case invalidBlockMode
    public static func == (a: cryptography.Blowfish.Error, b: cryptography.Blowfish.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, blockMode: cryptography.CryptoSwiftBlockMode = CryptoSwiftCBC(iv: Array<UInt8>(repeating: 0, count: Blowfish.blockSize)), padding: cryptography.CryptoSwiftPadding) throws
  @objc deinit
}
extension cryptography.Blowfish : cryptography.CryptoSwiftCipher {
  final public func encrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
  final public func decrypt<C>(_ bytes: C) throws -> Swift.Array<Swift.UInt8> where C : Swift.Collection, C.Element == Swift.UInt8, C.Index == Swift.Int
}
extension Swift.String : Swift.Error {
}
@_hasMissingDesignatedInitializers open class RSA {
  public typealias CCAsymmetricPadding = Swift.UInt32
  public enum AsymmetricPadding : cryptography.RSA.CCAsymmetricPadding {
    case pkcs1
    case oaep
    public init?(rawValue: cryptography.RSA.CCAsymmetricPadding)
    public typealias RawValue = cryptography.RSA.CCAsymmetricPadding
    public var rawValue: cryptography.RSA.CCAsymmetricPadding {
      get
    }
  }
  public enum AsymmetricSAPadding : Swift.UInt32 {
    case pkcs15
    case pss
    public init?(rawValue: Swift.UInt32)
    public typealias RawValue = Swift.UInt32
    public var rawValue: Swift.UInt32 {
      get
    }
  }
  public static func generateKeyPair(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
  public static func getPublicKeyFromPrivateKey(_ derKey: Foundation.Data) throws -> Foundation.Data
  public static func encrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: cryptography.RSA.AsymmetricPadding, digest: cryptography.DigestAlgorithm) throws -> Foundation.Data
  public static func decrypt(_ data: Foundation.Data, derKey: Foundation.Data, tag: Foundation.Data, padding: cryptography.RSA.AsymmetricPadding, digest: cryptography.DigestAlgorithm) throws -> (Foundation.Data, Swift.Int)
  public static func importFromDERKey(_ derKey: Foundation.Data) throws -> cryptography.RSA.CCRSACryptorRef
  public static func exportToDERKey(_ key: cryptography.RSA.CCRSACryptorRef) throws -> Foundation.Data
  public static func getKeyType(_ key: cryptography.RSA.CCRSACryptorRef) -> cryptography.RSA.KeyType
  public static func getKeySize(_ key: cryptography.RSA.CCRSACryptorRef) -> Swift.Int
  public static func parsePublicSecKey(publicKey: Security.SecKey) throws -> (modulus: Foundation.Data, exponent: Foundation.Data)
  public static func convertDERtoPublicKey(publicKey: Swift.String?, secAttrKeySizeInBits: Swift.Int) -> Security.SecKey?
  public static func sign(message: Foundation.Data, derKey: Foundation.Data, padding: cryptography.RSA.AsymmetricSAPadding, digest: cryptography.DigestAlgorithm, saltLen: Swift.Int) throws -> Foundation.Data
  public static func verify(message: Foundation.Data, derKey: Foundation.Data, padding: cryptography.RSA.AsymmetricSAPadding, digest: cryptography.DigestAlgorithm, saltLen: Swift.Int, signedData: Foundation.Data) throws -> Swift.Bool
  public static func crypt(_ data: Foundation.Data, key: cryptography.RSA.CCRSACryptorRef) throws -> Foundation.Data
  public static func mgf1(_ digest: cryptography.DigestAlgorithm, seed: Foundation.Data, maskLength: Swift.Int) -> Foundation.Data
  public static func xorData(_ data1: Foundation.Data, _ data2: Foundation.Data) -> Foundation.Data
  public static func add_pss_padding(_ digest: cryptography.DigestAlgorithm, saltLength: Swift.Int, keyLength: Swift.Int, message: Foundation.Data) throws -> Foundation.Data
  public static func verify_pss_padding(_ digest: cryptography.DigestAlgorithm, saltLength: Swift.Int, keyLength: Swift.Int, message: Foundation.Data, encMessage: Foundation.Data) throws -> Swift.Bool
  public static func generateKeyPair1(_ keySize: Swift.Int = 4096) throws -> (Foundation.Data, Foundation.Data)
  public static func available() -> Swift.Bool
  public typealias CCRSACryptorRef = Swift.UnsafeRawPointer
  public typealias CCRSAKeyType = Swift.UInt32
  public enum KeyType : cryptography.RSA.CCRSAKeyType {
    case publicKey, privateKey
    case blankPublicKey, blankPrivateKey
    case badKey
    public init?(rawValue: cryptography.RSA.CCRSAKeyType)
    public typealias RawValue = cryptography.RSA.CCRSAKeyType
    public var rawValue: cryptography.RSA.CCRSAKeyType {
      get
    }
  }
  public typealias CCRSACryptorGeneratePairT = @convention(c) (_ keySize: Swift.Int, _ e: Swift.UInt32, _ publicKey: Swift.UnsafeMutablePointer<cryptography.RSA.CCRSACryptorRef?>, _ privateKey: Swift.UnsafeMutablePointer<cryptography.RSA.CCRSACryptorRef?>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorGeneratePair: cryptography.RSA.CCRSACryptorGeneratePairT?
  public typealias CCRSACryptorGetPublicKeyFromPrivateKeyT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> cryptography.RSA.CCRSACryptorRef
  public static let CCRSACryptorGetPublicKeyFromPrivateKey: cryptography.RSA.CCRSACryptorGetPublicKeyFromPrivateKeyT?
  public typealias CCRSACryptorReleaseT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> Swift.Void
  public static let CCRSACryptorRelease: cryptography.RSA.CCRSACryptorReleaseT?
  public typealias CCRSAGetKeyTypeT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> cryptography.RSA.CCRSAKeyType
  public static let CCRSAGetKeyType: cryptography.RSA.CCRSAGetKeyTypeT?
  public typealias CCRSAGetKeySizeT = @convention(c) (cryptography.RSA.CCRSACryptorRef) -> Swift.Int32
  public static let CCRSAGetKeySize: cryptography.RSA.CCRSAGetKeySizeT?
  public typealias CCRSACryptorEncryptT = @convention(c) (_ publicKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ plainText: Swift.UnsafeRawPointer, _ plainTextLen: Swift.Int, _ cipherText: Swift.UnsafeMutableRawPointer, _ cipherTextLen: Swift.UnsafeMutablePointer<Swift.Int>, _ tagData: Swift.UnsafeRawPointer, _ tagDataLen: Swift.Int, _ digestType: cryptography.CC.CCDigestAlgorithm) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorEncrypt: cryptography.RSA.CCRSACryptorEncryptT?
  public typealias CCRSACryptorDecryptT = @convention(c) (_ privateKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ cipherText: Swift.UnsafeRawPointer, _ cipherTextLen: Swift.Int, _ plainText: Swift.UnsafeMutableRawPointer, _ plainTextLen: Swift.UnsafeMutablePointer<Swift.Int>, _ tagData: Swift.UnsafeRawPointer, _ tagDataLen: Swift.Int, _ digestType: cryptography.CC.CCDigestAlgorithm) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorDecrypt: cryptography.RSA.CCRSACryptorDecryptT?
  public typealias CCRSACryptorExportT = @convention(c) (_ key: cryptography.RSA.CCRSACryptorRef, _ out: Swift.UnsafeMutableRawPointer, _ outLen: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorExport: cryptography.RSA.CCRSACryptorExportT?
  public typealias CCRSACryptorImportT = @convention(c) (_ keyPackage: Swift.UnsafeRawPointer, _ keyPackageLen: Swift.Int, _ key: Swift.UnsafeMutablePointer<cryptography.RSA.CCRSACryptorRef?>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorImport: cryptography.RSA.CCRSACryptorImportT?
  public typealias CCRSACryptorSignT = @convention(c) (_ privateKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ hashToSign: Swift.UnsafeRawPointer, _ hashSignLen: Darwin.size_t, _ digestType: cryptography.CC.CCDigestAlgorithm, _ saltLen: Darwin.size_t, _ signedData: Swift.UnsafeMutableRawPointer, _ signedDataLen: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorSign: cryptography.RSA.CCRSACryptorSignT?
  public typealias CCRSACryptorVerifyT = @convention(c) (_ publicKey: cryptography.RSA.CCRSACryptorRef, _ padding: cryptography.RSA.CCAsymmetricPadding, _ hash: Swift.UnsafeRawPointer, _ hashLen: Darwin.size_t, _ digestType: cryptography.CC.CCDigestAlgorithm, _ saltLen: Darwin.size_t, _ signedData: Swift.UnsafeRawPointer, _ signedDataLen: Darwin.size_t) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorVerify: cryptography.RSA.CCRSACryptorVerifyT?
  public typealias CCRSACryptorCryptT = @convention(c) (_ rsaKey: cryptography.RSA.CCRSACryptorRef, _ data: Swift.UnsafeRawPointer, _ dataLength: Darwin.size_t, _ out: Swift.UnsafeMutableRawPointer, _ outLength: Swift.UnsafeMutablePointer<Darwin.size_t>) -> cryptography.CC.CCCryptorStatus
  public static let CCRSACryptorCrypt: cryptography.RSA.CCRSACryptorCryptT?
  @objc deinit
}
final public class CryptoSwiftGCM : cryptography.CryptoSwiftBlockMode {
  public enum Mode {
    case combined
    case detached
    public static func == (a: cryptography.CryptoSwiftGCM.Mode, b: cryptography.CryptoSwiftGCM.Mode) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let options: cryptography.CryptoSwiftBlockModeOption
  public enum Error : Swift.Error {
    case invalidInitializationVector
    case fail
    public static func == (a: cryptography.CryptoSwiftGCM.Error, b: cryptography.CryptoSwiftGCM.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let customBlockSize: Swift.Int?
  final public var authenticationTag: Swift.Array<Swift.UInt8>?
  public init(iv: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, tagLength: Swift.Int = 16, mode: cryptography.CryptoSwiftGCM.Mode = .detached)
  convenience public init(iv: Swift.Array<Swift.UInt8>, authenticationTag: Swift.Array<Swift.UInt8>, additionalAuthenticatedData: Swift.Array<Swift.UInt8>? = nil, mode: cryptography.CryptoSwiftGCM.Mode = .detached)
  final public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
  @objc deinit
}
final public class CryptoSwiftRabbit {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    public static func == (a: cryptography.CryptoSwiftRabbit.Error, b: cryptography.CryptoSwiftRabbit.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let ivSize: Swift.Int
  public static let keySize: Swift.Int
  public static let blockSize: Swift.Int
  final public var keySize: Swift.Int {
    get
  }
  convenience public init(key: Swift.Array<Swift.UInt8>) throws
  public init(key: Swift.Array<Swift.UInt8>, iv: Swift.Array<Swift.UInt8>?) throws
  @objc deinit
}
extension cryptography.CryptoSwiftRabbit : cryptography.CryptoSwiftCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension Swift.Array {
  @inlinable internal init(reserveCapacity: Swift.Int) {
    self = Array<Element>()
    self.reserveCapacity(reserveCapacity)
  }
  @inlinable internal var slice: Swift.ArraySlice<Element> {
    get {
    self[self.startIndex ..< self.endIndex]
  }
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public init(hex: Swift.String)
  public func toHexString() -> Swift.String
}
extension Swift.Array where Element == Swift.UInt8 {
  @available(*, deprecated)
  public func chunks(size chunksize: Swift.Int) -> Swift.Array<Swift.Array<Element>>
  public func md5() -> [Element]
  public func sha1() -> [Element]
  public func sha224() -> [Element]
  public func sha256() -> [Element]
  public func sha384() -> [Element]
  public func sha512() -> [Element]
  public func sha2(_ variant: cryptography.CryptoSwiftSHA2.Variant) -> [Element]
  public func sha3(_ variant: cryptography.CryptoSwiftSHA3.Variant) -> [Element]
  public func crc32(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc32c(seed: Swift.UInt32? = nil, reflect: Swift.Bool = true) -> Swift.UInt32
  public func crc16(seed: Swift.UInt16? = nil) -> Swift.UInt16
  public func encrypt(cipher: cryptography.CryptoSwiftCipher) throws -> [Element]
  public func decrypt(cipher: cryptography.CryptoSwiftCipher) throws -> [Element]
  public func authenticate<A>(with authenticator: A) throws -> [Element] where A : cryptography.CryptoSwiftAuthenticator
}
public class FoundationHTTPHandler : cryptography.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: cryptography.HTTPHandlerDelegate)
  @objc deinit
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: cryptography.WebSocketEvent)
}
public protocol Engine {
  func register(delegate: cryptography.EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: cryptography.FrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
public let NUMERIC_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_SYMBOL_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_COMPLEX_REGULAR_EXPRESSION: Swift.String
public let ALPHA_NUMERIC_SYMBOL_COMPLEX_REGULAR_EXPRESSION: Swift.String
public enum PasswordPolicyType : Swift.String, Swift.Codable {
  case numeric
  case alphaNumeric
  case alphaNumeric_symbol
  case alphaNumeric_complex
  case alphaNumeric_symbol_complex
  public init(from decoder: Swift.Decoder) throws
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum DigestAlgorithm : cryptography.CC.CCDigestAlgorithm {
  case none
  case md5
  case rmd128, rmd160, rmd256, rmd320
  case sha1
  case sha224, sha256, sha384, sha512
  public init?(rawValue: cryptography.CC.CCDigestAlgorithm)
  public typealias RawValue = cryptography.CC.CCDigestAlgorithm
  public var rawValue: cryptography.CC.CCDigestAlgorithm {
    get
  }
}
extension Foundation.URLRequest {
  public enum HTTPMethod : Swift.String {
    case get
    case put
    case post
    case delete
    case head
    case options
    case trace
    case connect
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public var method: Foundation.URLRequest.HTTPMethod? {
    get
    set
  }
}
extension Foundation.URLRequest {
  public init(url: Foundation.URL, method: Foundation.URLRequest.HTTPMethod, contentType: Swift.String?)
  public init(url: Foundation.URL, method: Foundation.URLRequest.HTTPMethod, contentType: Swift.String?, body: Foundation.Data?)
  public init(url: Foundation.URL, method: Foundation.URLRequest.HTTPMethod, contentType: Swift.String?, cachePolicy: Foundation.URLRequest.CachePolicy, timeoutInterval: Foundation.TimeInterval)
}
@_hasMissingDesignatedInitializers open class CC {
  public typealias CCCryptorStatus = Swift.Int32
  public static func generateRandom(_ size: Swift.Int) -> Foundation.Data
  public typealias CCDigestAlgorithm = Swift.UInt32
  public static func digest(_ data: Foundation.Data, alg: cryptography.DigestAlgorithm) -> Foundation.Data
  public typealias CCHmacAlgorithm = Swift.UInt32
  public static func HMAC(_ data: Foundation.Data, alg: cryptography.HMACAlg, key: Foundation.Data) -> Foundation.Data
  public typealias CCOperation = Swift.UInt32
  public typealias CCMode = Swift.UInt32
  public typealias CCAlgorithm = Swift.UInt32
  public typealias CCPadding = Swift.UInt32
  public static func crypt(_ opMode: cryptography.OpMode, blockMode: cryptography.BlockMode, algorithm: cryptography.Algorithm, padding: cryptography.Padding, data: Foundation.Data, key: Foundation.Data, iv: Foundation.Data) throws -> Foundation.Data
  public static func cryptAuth(_ opMode: cryptography.OpMode, blockMode: cryptography.AuthBlockMode, algorithm: cryptography.Algorithm, data: Foundation.Data, aData: Foundation.Data, key: Foundation.Data, iv: Foundation.Data, tagLength: Swift.Int) throws -> Foundation.Data
  public static func digestAvailable() -> Swift.Bool
  public static func randomAvailable() -> Swift.Bool
  public static func hmacAvailable() -> Swift.Bool
  public static func cryptorAvailable() -> Swift.Bool
  public static func available() -> Swift.Bool
  public typealias CCCryptorRef = Swift.UnsafeRawPointer
  public typealias CCRNGStatus = cryptography.CC.CCCryptorStatus
  public typealias CC_LONG = Swift.UInt32
  public typealias CCModeOptions = Swift.UInt32
  public typealias CCRandomGenerateBytesT = @convention(c) (_ bytes: Swift.UnsafeMutableRawPointer, _ count: Darwin.size_t) -> cryptography.CC.CCRNGStatus
  public typealias CCDigestGetOutputSizeT = @convention(c) (_ algorithm: cryptography.CC.CCDigestAlgorithm) -> Darwin.size_t
  public typealias CCDigestT = @convention(c) (_ algorithm: cryptography.CC.CCDigestAlgorithm, _ data: Swift.UnsafeRawPointer, _ dataLen: Darwin.size_t, _ output: Swift.UnsafeMutableRawPointer) -> Swift.CInt
  public typealias CCHmacT = @convention(c) (_ algorithm: cryptography.CC.CCHmacAlgorithm, _ key: Swift.UnsafeRawPointer, _ keyLength: Swift.Int, _ data: Swift.UnsafeRawPointer, _ dataLength: Swift.Int, _ macOut: Swift.UnsafeMutableRawPointer) -> Swift.Void
  public typealias CCCryptorCreateWithModeT = @convention(c) (_ op: cryptography.CC.CCOperation, _ mode: cryptography.CC.CCMode, _ alg: cryptography.CC.CCAlgorithm, _ padding: cryptography.CC.CCPadding, _ iv: Swift.UnsafeRawPointer?, _ key: Swift.UnsafeRawPointer, _ keyLength: Swift.Int, _ tweak: Swift.UnsafeRawPointer?, _ tweakLength: Swift.Int, _ numRounds: Swift.Int32, _ options: cryptography.CC.CCModeOptions, _ cryptorRef: Swift.UnsafeMutablePointer<cryptography.CC.CCCryptorRef?>) -> cryptography.CC.CCCryptorStatus
  public typealias CCCryptorGetOutputLengthT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef, _ inputLength: Darwin.size_t, _ final: Swift.Bool) -> Darwin.size_t
  public typealias CCCryptorUpdateT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef, _ dataIn: Swift.UnsafeRawPointer, _ dataInLength: Swift.Int, _ dataOut: Swift.UnsafeMutableRawPointer, _ dataOutAvailable: Swift.Int, _ dataOutMoved: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public typealias CCCryptorFinalT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef, _ dataOut: Swift.UnsafeMutableRawPointer, _ dataOutAvailable: Swift.Int, _ dataOutMoved: Swift.UnsafeMutablePointer<Swift.Int>) -> cryptography.CC.CCCryptorStatus
  public typealias CCCryptorReleaseT = @convention(c) (_ cryptorRef: cryptography.CC.CCCryptorRef) -> cryptography.CC.CCCryptorStatus
  public static let dl: Swift.UnsafeMutableRawPointer?
  public static let CCDigestGetOutputSize: cryptography.CC.CCDigestGetOutputSizeT?
  public static let CCDigest: cryptography.CC.CCDigestT?
  public static let CCHmac: cryptography.CC.CCHmacT?
  public static let CCCryptorCreateWithMode: cryptography.CC.CCCryptorCreateWithModeT?
  public static let CCCryptorGetOutputLength: cryptography.CC.CCCryptorGetOutputLengthT?
  public static let CCCryptorUpdate: cryptography.CC.CCCryptorUpdateT?
  public static let CCCryptorFinal: cryptography.CC.CCCryptorFinalT?
  public static let CCCryptorRelease: cryptography.CC.CCCryptorReleaseT?
  @objc deinit
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
final public class ChaCha20 {
  public enum Error : Swift.Error {
    case invalidKeyOrInitializationVector
    case notSupported
    public static func == (a: cryptography.ChaCha20.Error, b: cryptography.ChaCha20.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static let blockSize: Swift.Int
  final public let keySize: Swift.Int
  public init(key: Swift.Array<Swift.UInt8>, iv nonce: Swift.Array<Swift.UInt8>) throws
  @objc deinit
}
extension cryptography.ChaCha20 : cryptography.CryptoSwiftCipher {
  final public func encrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  final public func decrypt(_ bytes: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
}
extension cryptography.ChaCha20 {
  public struct ChaChaEncryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension cryptography.ChaCha20 {
  public struct ChaChaDecryptor : cryptography.CryptoSwiftCryptor, cryptography.CryptoSwiftUpdatable {
    public mutating func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = true) throws -> Swift.Array<Swift.UInt8>
    public func seek(to: Swift.Int) throws
  }
}
extension cryptography.ChaCha20 : cryptography.CryptoSwiftCryptors {
  final public func makeEncryptor() -> cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
  final public func makeDecryptor() -> cryptography.CryptoSwiftCryptor & cryptography.CryptoSwiftUpdatable
}
@_hasMissingDesignatedInitializers open class KeyWrap {
  public static let rfc3394IV: Foundation.Data
  public static func SymmetricKeyWrap(_ iv: Foundation.Data, kek: Foundation.Data, rawKey: Foundation.Data) throws -> Foundation.Data
  public static func SymmetricKeyUnwrap(_ iv: Foundation.Data, kek: Foundation.Data, wrappedKey: Foundation.Data) throws -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
public class PKCS7 {
  final public let mainBlock: cryptography.ASN1Object
  public init(data: Foundation.Data) throws
  public var digestAlgorithm: Swift.String? {
    get
  }
  public var digestAlgorithmName: Swift.String? {
    get
  }
  public var certificate: cryptography.X509Certificate? {
    get
  }
  public var certificates: [cryptography.X509Certificate] {
    get
  }
  public var data: Foundation.Data? {
    get
  }
  @objc deinit
}
public enum SignitureType : Swift.String {
  case RSA_PKCS1
  case RSA_PKCS1_ASN1
  case SHA1_RSA_PKCS1_ASN1
  case SHA2_256_RSA_PKCS1_ASN1
  case SHA2_384_RSA_PKCS1_ASN1
  case SHA2_512_RSA_PKCS1_ASN1
  public var algo: Security.SecKeyAlgorithm {
    get
  }
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Swift.FixedWidthInteger {
  @inlinable internal func bytes(totalBytes: Swift.Int = MemoryLayout<Self>.size) -> Swift.Array<Swift.UInt8> {
    arrayOfBytes(value: self.littleEndian, length: totalBytes)
    // TODO: adjust bytes order
    // var value = self.littleEndian
    // return withUnsafeBytes(of: &value, Array.init).reversed()
  }
}
@_hasMissingDesignatedInitializers public class ASN1Identifier : Swift.CustomStringConvertible {
  public enum Class : Swift.UInt8 {
    case universal
    case application
    case contextSpecific
    case `private`
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public enum TagNumber : Swift.UInt8 {
    case endOfContent
    case boolean
    case integer
    case bitString
    case octetString
    case null
    case objectIdentifier
    case objectDescriptor
    case external
    case read
    case enumerated
    case embeddedPdv
    case utf8String
    case relativeOid
    case sequence
    case set
    case numericString
    case printableString
    case t61String
    case videotexString
    case ia5String
    case utcTime
    case generalizedTime
    case graphicString
    case visibleString
    case generalString
    case universalString
    case characterString
    case bmpString
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let constructedTag: Swift.UInt8
  public func typeClass() -> cryptography.ASN1Identifier.Class
  public func isPrimitive() -> Swift.Bool
  public func isConstructed() -> Swift.Bool
  public func tagNumber() -> cryptography.ASN1Identifier.TagNumber
  public var description: Swift.String {
    get
  }
  @objc deinit
}
public func withUnsafePointers<A0, A1, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, Result>(_ arg0: Foundation.Data, _ arg1: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafeMutablePointer<A1>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ arg2: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>, Swift.UnsafeMutablePointer<A2>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, Result>(_ arg0: inout Foundation.Data, _ arg1: inout Foundation.Data, _ arg2: inout Foundation.Data, _ body: (Swift.UnsafeMutablePointer<A0>, Swift.UnsafeMutablePointer<A1>, Swift.UnsafeMutablePointer<A2>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, A3, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ arg2: Foundation.Data, _ arg3: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>, Swift.UnsafePointer<A2>, Swift.UnsafeMutablePointer<A3>) throws -> Result) rethrows -> Result
public func withUnsafePointers<A0, A1, A2, A3, A4, A5, Result>(_ arg0: Foundation.Data, _ arg1: Foundation.Data, _ arg2: Foundation.Data, _ arg3: Foundation.Data, _ arg4: inout Foundation.Data, _ arg5: inout Foundation.Data, _ body: (Swift.UnsafePointer<A0>, Swift.UnsafePointer<A1>, Swift.UnsafePointer<A2>, Swift.UnsafePointer<A3>, Swift.UnsafeMutablePointer<A4>, Swift.UnsafeMutablePointer<A5>) throws -> Result) rethrows -> Result
public func getFunc<T>(_ from: Swift.UnsafeMutableRawPointer, f: Swift.String) -> T?
extension Foundation.Data {
  public func hexadecimalString() -> Swift.String
  public func arrayOfBytes() -> [Swift.UInt8]
  public var bytesView: Foundation.Data.BytesView {
    get
  }
  public func bytesViewRange(_ range: Foundation.NSRange) -> Foundation.Data.BytesView
  public struct BytesView : Swift.Collection {
    public subscript(position: Swift.Int) -> Swift.UInt8 {
      get
    }
    public subscript(bounds: Swift.Range<Swift.Int>) -> Foundation.Data {
      get
    }
    public func formIndex(after i: inout Swift.Int)
    public func index(after i: Swift.Int) -> Swift.Int
    public var startIndex: Swift.Int
    public var endIndex: Swift.Int
    public var length: Swift.Int {
      get
    }
    public typealias Element = Swift.UInt8
    public typealias Index = Swift.Int
    public typealias Indices = Swift.DefaultIndices<Foundation.Data.BytesView>
    public typealias Iterator = Swift.IndexingIterator<Foundation.Data.BytesView>
    public typealias SubSequence = Foundation.Data
  }
}
extension Swift.String {
  public func dataFromHexadecimalString() -> Foundation.Data?
}
public protocol CryptoSwiftCipherModeWorker {
  var cipherOperation: cryptography.CipherOperationOnBlock { get }
  var additionalBufferSize: Swift.Int { get }
  @inlinable mutating func encrypt(block plaintext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @inlinable mutating func decrypt(block ciphertext: Swift.ArraySlice<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
}
public protocol CryptoSwiftBlockModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  var blockSize: Swift.Int { get }
}
public protocol CryptoSwiftCounterModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  associatedtype Counter
  var counter: Self.Counter { get set }
}
public protocol CryptoSwiftSeekableModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  mutating func seek(to position: Swift.Int) throws
}
public protocol CryptoSwiftStreamModeWorker : cryptography.CryptoSwiftCipherModeWorker {
}
public protocol CryptoSwiftFinalizingEncryptModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  mutating func finalize(encrypt ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
public protocol CryptoSwiftFinalizingDecryptModeWorker : cryptography.CryptoSwiftCipherModeWorker {
  @discardableResult
  mutating func willDecryptLast(bytes ciphertext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func didDecryptLast(bytes plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
  mutating func finalize(decrypt plaintext: Swift.ArraySlice<Swift.UInt8>) throws -> Swift.ArraySlice<Swift.UInt8>
}
@_hasMissingDesignatedInitializers public class ASN1DEREncoder {
  public static func encodeSequence(content: Foundation.Data) -> Foundation.Data
  @objc deinit
}
extension Foundation.Data {
  public var derEncodedSequence: Foundation.Data {
    get
  }
}
public enum PEMError : Swift.Error {
  case parse(Swift.String)
  case badPassphrase
  case keyNotEncrypted
  public static var debugLevel: Swift.Int
}
final public class CryptoSwiftMD5 {
  public init()
  final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8>
  @objc deinit
}
extension cryptography.CryptoSwiftMD5 : cryptography.CryptoSwiftUpdatable {
  final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8>
}
final public class CryptoSwiftHMAC : cryptography.CryptoSwiftAuthenticator {
  public enum Error : Swift.Error {
    case authenticateError
    case invalidInput
    public static func == (a: cryptography.CryptoSwiftHMAC.Error, b: cryptography.CryptoSwiftHMAC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Variant {
    case md5
    case sha1
    case sha2(cryptography.CryptoSwiftSHA2.Variant)
    case sha3(cryptography.CryptoSwiftSHA3.Variant)
    @available(*, deprecated, message: "Use sha2(variant) instead.")
    case sha256, sha384, sha512
  }
  public init(key: Swift.Array<Swift.UInt8>, variant: cryptography.CryptoSwiftHMAC.Variant = .md5)
  final public func authenticate(_ bytes: Swift.Array<Swift.UInt8>) throws -> Swift.Array<Swift.UInt8>
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, cryptography.Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: cryptography.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: cryptography.FrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
public enum CryptoSwiftPKCS5 {
}
extension cryptography.CryptoSwiftAES {
  convenience public init(key: Swift.String, iv: Swift.String, padding: cryptography.CryptoSwiftPadding = .pkcs7) throws
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func showAnimation(_ completionBlock: @escaping () -> Swift.Void)
}
@_hasMissingDesignatedInitializers public class MSSUIKit {
  public static let frameworkBundle: Foundation.Bundle?
  public static let notificationKey: Swift.String
  public static var uiKitConfig: cryptography.MSSUIKitConfig
  public static func initial(host: UIKit.UIViewController)
  public static func showRAViewController(host: UIKit.UIViewController)
  public static func showLogin(host: UIKit.UIViewController)
  public static func showHome(host: UIKit.UIViewController)
  public static func showRegisteration(host: UIKit.UIViewController)
  public static func showRegistrationBySignedMsisdn(host: UIKit.UIViewController, msisdn: Swift.String, signedMsisdn: Swift.String)
  public static func showGenerateKey(host: UIKit.UIWindow, message: Swift.String, messageId: Swift.String, keyType: Swift.String)
  public static func showSign(host: UIKit.UIWindow, message: Swift.String, messageId: Swift.String, dtbs: Swift.String, keyIndex: Swift.Int, signType: Swift.String)
  public static func showSignPdf(host: UIKit.UIWindow, message: Swift.String, messageId: Swift.String, dtbs: Swift.String, keyIndex: Swift.Int, sginType: Swift.String, dcs: Swift.String)
  public static func showLoginErorrDialog(host: UIKit.UIWindow, message: Swift.String)
  public static func showSessionExpiredTimeErorr(host: UIKit.UIWindow)
  public static func showDeleteKey(host: UIKit.UIWindow, deleteKey: Swift.String)
  public static func showChangePasswordViewController(host: UIKit.UIWindow)
  @objc deinit
}
public struct MSSUIKitConfig {
  public var pageBackgroundResId: UIKit.UIColor
  public var buttonCornerRadiusDimenResId: CoreGraphics.CGFloat
  public var buttonBorderWidthDimenResId: CoreGraphics.CGFloat
  public var buttonBackgroundColorResId: UIKit.UIColor
  public var buttonTextColorResId: UIKit.UIColor
  public var buttonBorderColorResId: UIKit.UIColor
  public var buttonFont: UIKit.UIFont
  public var backButtonBackgroundColorResId: UIKit.UIColor
  public var backButtonBorderColorResId: UIKit.UIColor
  public var backButtonCornerRadiusDimenResId: CoreGraphics.CGFloat
  public var backButtonBorderWidthDimenResId: CoreGraphics.CGFloat
  public var backButtonTextColorResId: UIKit.UIColor
  public var backButtonFont: UIKit.UIFont
  public var titleTextColorResId: UIKit.UIColor
  public var titleTextViewFont: UIKit.UIFont
  public var subTitleTextColor: UIKit.UIColor
  public var subTitleTextViewFont: UIKit.UIFont
  public var editTextCornerRadiusDimenResId: CoreGraphics.CGFloat
  public var editTextBorderWidthDimenResId: CoreGraphics.CGFloat
  public var editTextBackgroundColorResId: UIKit.UIColor
  public var editTextBorderColorResId: UIKit.UIColor
  public var editTextColorResId: UIKit.UIColor
  public var editTextCursorColor: UIKit.UIColor
  public var editTextFont: UIKit.UIFont
  public var logoDrawableResId: UIKit.UIImage?
  public var popUpTitleTextColorResId: UIKit.UIColor
  public var popUpTitleTextViewFont: UIKit.UIFont
  public var popUpDisplayMessageTextColorResId: UIKit.UIColor
  public var popUpDisplayMessageTextViewFont: UIKit.UIFont
  public func returnKernel(_ named: Swift.String) -> Swift.String?
}
public class MSSUIKitConfigBuilder {
  public init()
  public var pageBackgroundResId: UIKit.UIColor
  public func setPageBackgroundResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBackgroundColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonCornerRadiusDimenResId(size: CoreGraphics.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonBorderWidthDimenResId(size: CoreGraphics.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setButtonFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonBackgroundColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonCornerRadiusDimenResId(size: CoreGraphics.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonBorderWidthDimenResId(size: CoreGraphics.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setBackButtonFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setTitleTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setTitleTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setSubTitleTextColor(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setSubTitleTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextBackgroundColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextBorderColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextCursorColor(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextCornerRadiusDimenResId(size: CoreGraphics.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func setEditTextBorderWidthDimenResId(size: CoreGraphics.CGFloat) -> cryptography.MSSUIKitConfigBuilder
  public func editTextFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setLogoDrawableResId(logoImage: UIKit.UIImage) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpTitleTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpTitleTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpDisplayMessageTextColorResId(color: UIKit.UIColor) -> cryptography.MSSUIKitConfigBuilder
  public func setPopUpDisplayMessageTextViewFont(font: UIKit.UIFont) -> cryptography.MSSUIKitConfigBuilder
  public func build() -> cryptography.MSSUIKitConfig
  @objc deinit
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(cryptography.Frame)
  case error(Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: cryptography.FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: cryptography.FramerEventClient)
  func createWriteFrame(opcode: cryptography.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : cryptography.Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: cryptography.FramerEventClient)
  public func createWriteFrame(opcode: cryptography.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : cryptography.MyWSArrayType {
}
extension Swift.Array where Element : Swift.UnsignedInteger, Element : cryptography.MyWSArrayType {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
final public class CryptoSwiftSHA3 {
  final public let blockSize: Swift.Int
  final public let digestLength: Swift.Int
  final public let markByte: Swift.UInt8
  @usableFromInline
  final internal var accumulated: [Swift.UInt8]
  @usableFromInline
  final internal var accumulatedHash: Swift.Array<Swift.UInt64>
  public enum Variant {
    case sha224, sha256, sha384, sha512, keccak224, keccak256, keccak384, keccak512
    public var outputLength: Swift.Int {
      get
    }
    public static func == (a: cryptography.CryptoSwiftSHA3.Variant, b: cryptography.CryptoSwiftSHA3.Variant) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public init(variant: cryptography.CryptoSwiftSHA3.Variant)
  @inlinable final public func calculate(for bytes: Swift.Array<Swift.UInt8>) -> Swift.Array<Swift.UInt8> {
    do {
      return try update(withBytes: bytes.slice, isLast: true)
    } catch {
      return []
    }
  }
  @usableFromInline
  final internal func process(block chunk: Swift.ArraySlice<Swift.UInt64>, currentHash hh: inout Swift.Array<Swift.UInt64>)
  @objc deinit
}
extension cryptography.CryptoSwiftSHA3 : cryptography.CryptoSwiftUpdatable {
  @inlinable final public func update(withBytes bytes: Swift.ArraySlice<Swift.UInt8>, isLast: Swift.Bool = false) throws -> Swift.Array<Swift.UInt8> {
    self.accumulated += bytes

    if isLast {
      // Add padding
      let markByteIndex = self.accumulated.count

      // We need to always pad the input. Even if the input is a multiple of blockSize.
      let r = self.blockSize * 8
      let q = (r / 8) - (accumulated.count % (r / 8))
      self.accumulated += Array<UInt8>(repeating: 0, count: q)

      self.accumulated[markByteIndex] |= self.markByte
      self.accumulated[self.accumulated.count - 1] |= 0x80
    }

    var processedBytes = 0
    for chunk in self.accumulated.batched(by: self.blockSize) {
      if isLast || (self.accumulated.count - processedBytes) >= self.blockSize {
        self.process(block: chunk.toUInt64Array().slice, currentHash: &self.accumulatedHash)
        processedBytes += chunk.count
      }
    }
    self.accumulated.removeFirst(processedBytes)

    // TODO: verify performance, reduce vs for..in
    let result = self.accumulatedHash.reduce(into: Array<UInt8>()) { (result, value) in
      result += value.bigEndian.bytes()
    }

    // reset hash value for instance
    if isLast {
      self.accumulatedHash = Array<UInt64>(repeating: 0, count: self.digestLength)
    }

    return Array(result[0..<self.digestLength])
  }
}
extension Swift.Array where Element == Swift.UInt8 {
  public func toBase64() -> Swift.String
  public init(base64: Swift.String)
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed(Swift.Error?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: cryptography.ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: cryptography.TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: cryptography.CertificatePinning?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public struct CryptoSwiftCBC : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftCBC.Error, b: cryptography.CryptoSwiftCBC.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
public struct CryptoSwiftOFB : cryptography.CryptoSwiftBlockMode {
  public enum Error : Swift.Error {
    case invalidInitializationVector
    public static func == (a: cryptography.CryptoSwiftOFB.Error, b: cryptography.CryptoSwiftOFB.Error) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public let options: cryptography.CryptoSwiftBlockModeOption
  public let customBlockSize: Swift.Int?
  public init(iv: Swift.Array<Swift.UInt8>)
  public func worker(blockSize: Swift.Int, cipherOperation: @escaping cryptography.CipherOperationOnBlock, encryptionOperation: @escaping cryptography.CipherOperationOnBlock) throws -> cryptography.CryptoSwiftCipherModeWorker
}
@_hasMissingDesignatedInitializers open class PEM {
  public static func stripHeaderFooter(_ data: Swift.String, header: Swift.String, footer: Swift.String) -> Swift.String?
  public static func base64Decode(_ base64Data: Swift.String) -> Foundation.Data?
  public static func base64Encode(_ key: Foundation.Data) -> Swift.String
  @objc deinit
}
public enum Model : Swift.String {
  case simulator, iPod1, iPod2, iPod3, iPod4, iPod5, iPod6, iPod7, iPad2, iPad3, iPad4, iPadAir, iPadAir2, iPadAir3, iPadAir4, iPad5, iPad6, iPad7, iPad8, iPad9, iPadMini, iPadMini2, iPadMini3, iPadMini4, iPadMini5, iPadMini6, iPadPro9_7, iPadPro10_5, iPadPro11, iPadPro2_11, iPadPro3_11, iPadPro12_9, iPadPro2_12_9, iPadPro3_12_9, iPadPro4_12_9, iPadPro5_12_9, iPhone4, iPhone4S, iPhone5, iPhone5S, iPhone5C, iPhone6, iPhone6Plus, iPhone6S, iPhone6SPlus, iPhoneSE, iPhone7, iPhone7Plus, iPhone8, iPhone8Plus, iPhoneX, iPhoneXS, iPhoneXSMax, iPhoneXR, iPhone11, iPhone11Pro, iPhone11ProMax, iPhoneSE2, iPhone12Mini, iPhone12, iPhone12Pro, iPhone12ProMax, iPhone13Mini, iPhone13, iPhone13Pro, iPhone13ProMax, AppleWatch1, AppleWatchS1, AppleWatchS2, AppleWatchS3, AppleWatchS4, AppleWatchS5, AppleWatchSE, AppleWatchS6, AppleWatchS7, AppleTV1, AppleTV2, AppleTV3, AppleTV4, AppleTV_4K, AppleTV2_4K, unrecognized
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var type: cryptography.Model {
    get
  }
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public static var isSimulator: Swift.Bool
}
extension UIKit.UIDevice {
  @_Concurrency.MainActor(unsafe) public var typeModel: cryptography.Model {
    get
  }
}
public enum SocketCertificatePinningError : Swift.Error {
  case invalidRequest
  public static func == (a: cryptography.SocketCertificatePinningError, b: cryptography.SocketCertificatePinningError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class SocketCertificatePinning : cryptography.CertificatePinning {
  public init(certificateOfConfig: Foundation.Data, domainHost: Swift.String)
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((cryptography.PinningState) -> ()))
  @objc deinit
}
public protocol CryptoSwiftPaddingProtocol {
  func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
}
public enum CryptoSwiftPadding : cryptography.CryptoSwiftPaddingProtocol {
  case noPadding, zeroPadding, pkcs7, pkcs5, iso78164, iso10126
  public func add(to: Swift.Array<Swift.UInt8>, blockSize: Swift.Int) -> Swift.Array<Swift.UInt8>
  public func remove(from: Swift.Array<Swift.UInt8>, blockSize: Swift.Int?) -> Swift.Array<Swift.UInt8>
  public static func == (a: cryptography.CryptoSwiftPadding, b: cryptography.CryptoSwiftPadding) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers open class KeyDerivation {
  public typealias CCPseudoRandomAlgorithm = Swift.UInt32
  public enum PRFAlg : cryptography.KeyDerivation.CCPseudoRandomAlgorithm {
    case sha1, sha224, sha256, sha384, sha512
    public init?(rawValue: cryptography.KeyDerivation.CCPseudoRandomAlgorithm)
    public typealias RawValue = cryptography.KeyDerivation.CCPseudoRandomAlgorithm
    public var rawValue: cryptography.KeyDerivation.CCPseudoRandomAlgorithm {
      get
    }
  }
  public static func PBKDF2(_ password: Swift.String, salt: Foundation.Data, prf: cryptography.KeyDerivation.PRFAlg, rounds: Swift.UInt32) throws -> Foundation.Data
  public static func available() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers open class KeyConvertPrivateKey {
  public static func pemToPKCS1DER(_ pemKey: Swift.String) throws -> Foundation.Data
  public static func derToPKCS1PEM(_ derKey: Foundation.Data) -> Swift.String
  public typealias EncMode = cryptography.PEMEncryptedPrivateKey.EncMode
  public static func encryptPEM(_ pemKey: Swift.String, passphrase: Swift.String, mode: cryptography.KeyConvertPrivateKey.EncMode) throws -> Swift.String
  public static func decryptPEM(_ pemKey: Swift.String, passphrase: Swift.String) throws -> Swift.String
  @objc deinit
}
extension cryptography.CCError : Swift.Equatable {}
extension cryptography.CCError : Swift.Hashable {}
extension cryptography.CCError : Swift.RawRepresentable {}
extension cryptography.BlockMode : Swift.Equatable {}
extension cryptography.BlockMode : Swift.Hashable {}
extension cryptography.BlockMode : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftCTR : cryptography.CryptoSwiftBlockMode {}
extension cryptography.CryptoSwiftCTR.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCTR.Error : Swift.Hashable {}
extension cryptography.FoundationTransportError : Swift.Equatable {}
extension cryptography.FoundationTransportError : Swift.Hashable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftPKCS5.CryptoSwiftPBKDF1.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftSHA2.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftSHA2.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftSHA2.Variant : Swift.Sendable {}
extension cryptography.PEMEncryptedPrivateKey.EncMode : Swift.Equatable {}
extension cryptography.PEMEncryptedPrivateKey.EncMode : Swift.Hashable {}
extension cryptography.KeyType : Swift.Equatable {}
extension cryptography.KeyType : Swift.Hashable {}
extension cryptography.KeyType : Swift.RawRepresentable {}
extension cryptography.FoundationSecurityError : Swift.Equatable {}
extension cryptography.FoundationSecurityError : Swift.Hashable {}
extension cryptography.SecurityErrorCode : Swift.Equatable {}
extension cryptography.SecurityErrorCode : Swift.Hashable {}
extension cryptography.SecurityErrorCode : Swift.RawRepresentable {}
extension cryptography.KeyStoreEditorError : Swift.Equatable {}
extension cryptography.KeyStoreEditorError : Swift.Hashable {}
extension cryptography.KeyStoreEditorError : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftOCB.Mode : Swift.Equatable {}
extension cryptography.CryptoSwiftOCB.Mode : Swift.Hashable {}
extension cryptography.CryptoSwiftOCB.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftOCB.Error : Swift.Hashable {}
extension cryptography.lastIssueCertInProgressStepEnum : Swift.Equatable {}
extension cryptography.lastIssueCertInProgressStepEnum : Swift.Hashable {}
extension cryptography.KeyConvertError : Swift.Equatable {}
extension cryptography.KeyConvertError : Swift.Hashable {}
extension cryptography.CryptoSwiftBit : Swift.Equatable {}
extension cryptography.CryptoSwiftBit : Swift.Hashable {}
extension cryptography.CryptoSwiftBit : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftPoly1305.CryptoSwiftError : Swift.Equatable {}
extension cryptography.CryptoSwiftPoly1305.CryptoSwiftError : Swift.Hashable {}
extension cryptography.CryptoSwiftAES.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftAES.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftAES.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftAES.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftAES.Variant : Swift.RawRepresentable {}
extension cryptography.ErrorType : Swift.Equatable {}
extension cryptography.ErrorType : Swift.Hashable {}
extension cryptography.DHParam : Swift.Equatable {}
extension cryptography.DHParam : Swift.Hashable {}
extension cryptography.CryptoSwiftCMAC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCMAC.Error : Swift.Hashable {}
extension cryptography.OID : Swift.Equatable {}
extension cryptography.OID : Swift.Hashable {}
extension cryptography.OID : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftPCBC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftPCBC.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftHKDF.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftHKDF.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftPKCS5.PBKDF2.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftPKCS5.PBKDF2.Error : Swift.Hashable {}
extension cryptography.HMACAlg : Swift.Equatable {}
extension cryptography.HMACAlg : Swift.Hashable {}
extension cryptography.HMACAlg : Swift.RawRepresentable {}
extension cryptography.OpMode : Swift.Equatable {}
extension cryptography.OpMode : Swift.Hashable {}
extension cryptography.OpMode : Swift.RawRepresentable {}
extension cryptography.TCPTransportError : Swift.Equatable {}
extension cryptography.TCPTransportError : Swift.Hashable {}
extension cryptography.CipherError : Swift.Equatable {}
extension cryptography.CipherError : Swift.Hashable {}
extension cryptography.CRC.Mode : Swift.Equatable {}
extension cryptography.CRC.Mode : Swift.Hashable {}
extension cryptography.CRC.Mode : Swift.RawRepresentable {}
extension cryptography.Padding : Swift.Equatable {}
extension cryptography.Padding : Swift.Hashable {}
extension cryptography.Padding : Swift.RawRepresentable {}
extension cryptography.Algorithm : Swift.Equatable {}
extension cryptography.Algorithm : Swift.Hashable {}
extension cryptography.Algorithm : Swift.RawRepresentable {}
extension cryptography.AuthBlockMode : Swift.Equatable {}
extension cryptography.AuthBlockMode : Swift.Hashable {}
extension cryptography.AuthBlockMode : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftCCM : cryptography.CryptoSwiftBlockMode {}
extension cryptography.CryptoSwiftCCM.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCCM.Error : Swift.Hashable {}
extension cryptography.PersianDatePickerStyle : Swift.Equatable {}
extension cryptography.PersianDatePickerStyle : Swift.Hashable {}
extension cryptography.CryptoSwiftCFB.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCFB.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftCFB.SegmentSize : Swift.Equatable {}
extension cryptography.CryptoSwiftCFB.SegmentSize : Swift.Hashable {}
extension cryptography.CryptoSwiftCFB.SegmentSize : Swift.RawRepresentable {}
extension cryptography.Blowfish.Error : Swift.Equatable {}
extension cryptography.Blowfish.Error : Swift.Hashable {}
extension cryptography.RSA.AsymmetricPadding : Swift.Equatable {}
extension cryptography.RSA.AsymmetricPadding : Swift.Hashable {}
extension cryptography.RSA.AsymmetricPadding : Swift.RawRepresentable {}
extension cryptography.RSA.AsymmetricSAPadding : Swift.Equatable {}
extension cryptography.RSA.AsymmetricSAPadding : Swift.Hashable {}
extension cryptography.RSA.AsymmetricSAPadding : Swift.RawRepresentable {}
extension cryptography.RSA.KeyType : Swift.Equatable {}
extension cryptography.RSA.KeyType : Swift.Hashable {}
extension cryptography.RSA.KeyType : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftGCM.Mode : Swift.Equatable {}
extension cryptography.CryptoSwiftGCM.Mode : Swift.Hashable {}
extension cryptography.CryptoSwiftGCM.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftGCM.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftRabbit.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftRabbit.Error : Swift.Hashable {}
extension cryptography.PasswordPolicyType : Swift.Equatable {}
extension cryptography.PasswordPolicyType : Swift.Hashable {}
extension cryptography.PasswordPolicyType : Swift.RawRepresentable {}
extension cryptography.DigestAlgorithm : Swift.Equatable {}
extension cryptography.DigestAlgorithm : Swift.Hashable {}
extension cryptography.DigestAlgorithm : Swift.RawRepresentable {}
extension Foundation.URLRequest.HTTPMethod : Swift.Equatable {}
extension Foundation.URLRequest.HTTPMethod : Swift.Hashable {}
extension Foundation.URLRequest.HTTPMethod : Swift.RawRepresentable {}
extension cryptography.ChaCha20.Error : Swift.Equatable {}
extension cryptography.ChaCha20.Error : Swift.Hashable {}
extension cryptography.SignitureType : Swift.Equatable {}
extension cryptography.SignitureType : Swift.Hashable {}
extension cryptography.SignitureType : Swift.RawRepresentable {}
extension cryptography.ASN1Identifier.Class : Swift.Equatable {}
extension cryptography.ASN1Identifier.Class : Swift.Hashable {}
extension cryptography.ASN1Identifier.Class : Swift.RawRepresentable {}
extension cryptography.ASN1Identifier.TagNumber : Swift.Equatable {}
extension cryptography.ASN1Identifier.TagNumber : Swift.Hashable {}
extension cryptography.ASN1Identifier.TagNumber : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftHMAC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftHMAC.Error : Swift.Hashable {}
extension cryptography.CloseCode : Swift.Equatable {}
extension cryptography.CloseCode : Swift.Hashable {}
extension cryptography.CloseCode : Swift.RawRepresentable {}
extension cryptography.FrameOpCode : Swift.Equatable {}
extension cryptography.FrameOpCode : Swift.Hashable {}
extension cryptography.FrameOpCode : Swift.RawRepresentable {}
extension cryptography.CryptoSwiftSHA3.Variant : Swift.Equatable {}
extension cryptography.CryptoSwiftSHA3.Variant : Swift.Hashable {}
extension cryptography.CryptoSwiftCBC.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftCBC.Error : Swift.Hashable {}
extension cryptography.CryptoSwiftOFB.Error : Swift.Equatable {}
extension cryptography.CryptoSwiftOFB.Error : Swift.Hashable {}
extension cryptography.Model : Swift.Equatable {}
extension cryptography.Model : Swift.Hashable {}
extension cryptography.Model : Swift.RawRepresentable {}
extension cryptography.SocketCertificatePinningError : Swift.Equatable {}
extension cryptography.SocketCertificatePinningError : Swift.Hashable {}
extension cryptography.CryptoSwiftPadding : Swift.Equatable {}
extension cryptography.CryptoSwiftPadding : Swift.Hashable {}
extension cryptography.KeyDerivation.PRFAlg : Swift.Equatable {}
extension cryptography.KeyDerivation.PRFAlg : Swift.Hashable {}
extension cryptography.KeyDerivation.PRFAlg : Swift.RawRepresentable {}
